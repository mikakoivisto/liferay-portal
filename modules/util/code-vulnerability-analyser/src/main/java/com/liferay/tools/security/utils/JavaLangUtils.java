package com.liferay.tools.security.utils;

import org.slf4j.LoggerFactory;

import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.body.Parameter;
import com.github.javaparser.ast.type.PrimitiveType.Primitive;
import com.liferay.tools.security.AnalyserRuntimeException;
import com.liferay.tools.security.symbol.SymbolTable;
import com.liferay.tools.security.symbol.UnresolvableSymbolException;
import com.liferay.tools.security.symbol.resolution.ResolvableType;
import com.liferay.tools.security.symbol.resolution.strategy.ResolutionStrategy;

public class JavaLangUtils {

	/**
	 * Converts a method's declaration to a method signature.
	 * Method signatures only take into account method name and parameter types (See Java language spec)
	 * 
	 * @param method
	 * @return
	 */
	public static String getMethodSignatureString(MethodDeclaration method) {
		
		// Java applies the type erasure technique to produce method signatures for parameterized types
		// This method gets the SymbolTable associated with the RAW MethodDeclaration node
		// (and consequently parent nodes like ClassOrInterfaceDeclaration) in order to meet this requirement.
		return serializeMethodDeclaration(method, SymbolTable.getSymbolTableForMethod(method));
	}

	/**
	 * Serializes a method declaration. All type references are expanded to fully qualified form,
	 * including generic type arguments if the provided ResolutionStrategy is capable of doing so.
	 * 
	 * @param method
	 * @param rs
	 * @return
	 */
    public static String serializeMethodDeclaration(MethodDeclaration method, ResolutionStrategy rs) {
    	
		try {
			
			_log.trace("serializeMethodDeclaration() starting");
			
			StringBuffer sb = new StringBuffer();
			
			sb.append(method.getName());
			sb.append('(');
			if (method.getParameters() != null && method.getParameters().size() > 0) {
				for (Parameter param : method.getParameters()) {
					
					String resolvedType = rs.resolveType(param.getType().toString());
					if (resolvedType == null) throw new RuntimeException("Failed to resolve type reference: " + method.getType().toString());
					
					sb.append(resolvedType);
					sb.append(',');
					sb.append(' ');
				}
				sb.deleteCharAt(sb.length() - 1);
				sb.deleteCharAt(sb.length() - 1);
			}
			sb.append(')');
			
			_log.trace("getMethodSignatureString() returning: " + sb.toString());
		
			return sb.toString();
			
		} catch (UnresolvableSymbolException e) {
			throw new AnalyserRuntimeException(e);
		}
    }

    
    public static String getMethodSignatureString(String methodName, ResolvableType[] paramTypes) {
    	
    	StringBuffer sb = new StringBuffer();
		sb.append(methodName);
		sb.append('(');
		for (ResolvableType paramType : paramTypes) {
			sb.append(paramType.toString());
			sb.append(',');
			sb.append(' ');
		}
		if (sb.lastIndexOf(",") != -1) sb.delete(sb.lastIndexOf(","), sb.length());
		sb.append(')');
		
		return sb.toString();
    }

    private static int getNumericPromotionIndex(Primitive numericPrimitive) {
    	
    	switch (numericPrimitive) {
    	
    		case Byte:
    			return 0;
			case Short:
			case Char:
				return 1;
			case Int:
				return 2;
			case Long:
				return 3;
			case Float:
				return 4;
			case Double:
				return 5;
			default:
				return -1;
    	}
    			
    }
    
    public static boolean canPromoteNumericType(Primitive from, Primitive to) {
    	
    	// Booleans are not considered for promotion
    	if (from.equals(Primitive.Boolean) || to.equals(Primitive.Boolean)) return false;
    	
    	int fromIndex = getNumericPromotionIndex(from);
    	int toIndex = getNumericPromotionIndex(to);
    	
    	return fromIndex < toIndex;
    }
    
    private final static org.slf4j.Logger _log = LoggerFactory.getLogger(JavaLangUtils.class);
}
