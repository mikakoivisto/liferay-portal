package com.liferay.tools.security.utils;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import org.slf4j.LoggerFactory;

import com.github.javaparser.ASTHelper;
import com.github.javaparser.ast.Node;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.EnumDeclaration;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.body.Parameter;
import com.github.javaparser.ast.body.TypeDeclaration;
import com.github.javaparser.ast.type.ClassOrInterfaceType;
import com.github.javaparser.ast.type.PrimitiveType;
import com.github.javaparser.ast.type.PrimitiveType.Primitive;
import com.github.javaparser.ast.type.ReferenceType;
import com.github.javaparser.ast.type.Type;
import com.github.javaparser.ast.type.UnknownType;
import com.github.javaparser.ast.type.VoidType;
import com.liferay.tools.security.ClassLoader;
import com.liferay.tools.security.symbol.SymbolTable;
import com.liferay.tools.security.symbol.resolution.ResolvableType;
import com.liferay.tools.security.symbol.resolution.SimpleResolvableType;

public class StaticAnalysisUtils {

	public static ClassOrInterfaceDeclaration getClassDeclaration(Node n) {
		Node n2 = n;
		while (n2 != null && !((n2 = n2.getParentNode()) instanceof ClassOrInterfaceDeclaration)) {}
		return (ClassOrInterfaceDeclaration)n2;
	}
	
	public static ClassOrInterfaceType getSuperClassType(ClassOrInterfaceDeclaration n) {
		List<ClassOrInterfaceType> superClass = n.getExtends();
		if (superClass != null && superClass.size() > 0) {
			return superClass.get(0);
		} return null;
	}
	
	public static MethodDeclaration getMethodDeclaration(Node n) {
		Node n2 = n;
		while (n2 != null && !((n2 = n2.getParentNode()) instanceof MethodDeclaration)) {}
		return (MethodDeclaration)n2;
	}

	@Deprecated
	public static void injectQualifiedTypeNotation(Type type, SymbolTable symbolTable) {
		
		// If a SymbolTable has been provided, then ensure that the Type is in fully qualified notation
		if (type instanceof ReferenceType && symbolTable != null) {
			((ClassOrInterfaceType)((ReferenceType)type).getType()).setName(symbolTable.resolveType(type.toString()));
		}
	}	

    /**
     * Retrieves a method implementation given a method declaration on an Interface (or super class)
     * 
     * @param interfaceMethodDeclaration - the method on the Interface or super class
     * @param targetClassType - the class to find the method implementation on
     * @return
     */
    public static MethodDeclaration getMethodImpl(MethodDeclaration interfaceMethodDeclaration, Type targetClassType) {
    	
    	ClassOrInterfaceDeclaration classDef = (ClassOrInterfaceDeclaration)ClassLoader.getRequiredDefinition(targetClassType.toString());
    	return getMethodImpl(interfaceMethodDeclaration, classDef);
    }
    
    public static MethodDeclaration getMethodImpl(MethodDeclaration interfaceMethodDeclaration, TypeDeclaration classDef) {
    	
    	SymbolTable implSymbolTable = SymbolTable.getSymbolTableForType(classDef);
    	List<MethodDeclaration> methodImpls = implSymbolTable.getMethodDeclaration(interfaceMethodDeclaration.getName());
    	
    	ResolvableType[] callArguments = new ResolvableType[interfaceMethodDeclaration.getParameters().size()];
    	int i = 0;
    	
    	SymbolTable interfaceMethodSymbolTable = SymbolTable.getSymbolTableForMethod(interfaceMethodDeclaration);
    	for (Parameter param : interfaceMethodDeclaration.getParameters()) {
    		callArguments[i] = new SimpleResolvableType(param.getType(), interfaceMethodSymbolTable);
    		i++;
    	}
    	
    	for (MethodDeclaration methodImpl : methodImpls) {
    		
    		if (checkArgumentsCompatibility(callArguments, methodImpl.getParameters(), false))
    			return methodImpl;
    	}
    	
    	return null;
    }
    
	private static List<MethodDeclaration> getCompatibleMethods(
				ResolvableType[] callParamTypes,
				List<MethodDeclaration> methods
			) {
		
		List<MethodDeclaration> candidateMethods = new LinkedList<MethodDeclaration>();
		
		for (MethodDeclaration method : methods) {

			_log.trace("Consider method: " + getClassDeclaration(method).getName() + "#" + JavaLangUtils.getMethodSignatureString(method));
			
			if (callParamTypes == null && method.getParameters() == null) {
				candidateMethods.add(method);
				continue;				
			}

			if (callParamTypes == null || method.getParameters() == null) {
				_log.trace("Dismissing " + JavaLangUtils.getMethodSignatureString(method) + " because either argumetn OR parameter count is zero, but not both");
				continue;
			}

			// Don't consider methods that have a different number of parameters to the arguments provided
			if (callParamTypes.length != method.getParameters().size()) {
				_log.trace("Dismissing " + JavaLangUtils.getMethodSignatureString(method) + " because argument count is " + callParamTypes.length + " and parameter number is " + method.getParameters().size());
				continue;
			}
			
			// (Otherwise) consider methods with zero parameters
			if (callParamTypes.length == 0) {
				candidateMethods.add(method);
				continue;
			}
			
			SymbolTable methodSymbolTable = SymbolTable.getSymbolTableForMethod(method);
			
			if (method.getParameters() != null && method.getParameters().size() > 0) {	
				
				if (checkArgumentsCompatibility(callParamTypes, method.getParameters(), true))
					candidateMethods.add(method);
			}
			
		}
		return candidateMethods;
	} 	
	
	private static boolean checkArgumentsCompatibility(
			ResolvableType[] callParamTypes,
			List<Parameter> methodParams, 			
			boolean considerTypeInheritance) {
		
		if (methodParams.size() != callParamTypes.length) {
			return false;
		}
		
		if (methodParams.size() == 0) return true;
		
		SymbolTable methodSymbolTable = SymbolTable.getSymbolTableForMethod((MethodDeclaration)methodParams.get(0).getParentNode());
		
		int i = 0;
		for (Parameter param : methodParams) {
		
			ResolvableType callParamType = callParamTypes[i];
			
			if (!checkArgumentCompatibility(considerTypeInheritance, new SimpleResolvableType(param.getType(), methodSymbolTable), callParamType)) return false;
			
			i++;
		}
		
		return true;
	}

	private static boolean checkArgumentCompatibility(boolean considerTypeInheritance, ResolvableType param, ResolvableType arg) {
		
		Type paramType = param.getType();
		Type argType = arg.getType();
		
		_log.trace("Comparing parameter type " + paramType.toString() + " with argument type " + argType.toString());
		
		if (paramType instanceof ReferenceType && argType instanceof ReferenceType) {
			
			_log.trace("Comparing reference types");
			
			ReferenceType paramReferenceType = (ReferenceType)paramType;
			ReferenceType argReferenceType = (ReferenceType)argType;
			
			if (paramReferenceType.getArrayCount() == 0 
					&& param.getQualifiedType().equals("java.lang.Object")) {
					//&& paramReferenceType.getType() instanceof ClassOrInterfaceType
					//&& ((ClassOrInterfaceType)paramReferenceType.getType()).getName().equals("java.lang.object")) {
				
				return true;
			}
			
			if (paramReferenceType.getArrayCount() != argReferenceType.getArrayCount()) {
				_log.trace("Incompatible via array dimension count");
				return false;
			}
						
			if (paramReferenceType.getArrayCount() > 0) {
			
				if (paramReferenceType.getType().getClass().equals(argReferenceType.getType().getClass())) {
					
					_log.trace("Unwrapping reference types and re-checking...");
					
					// Compare primitive type compatibility
					return checkArgumentCompatibility(
							true,
							new SimpleResolvableType(paramReferenceType.getType(), param.getResolutionStrategy()),
							new SimpleResolvableType(argReferenceType.getType(), arg.getResolutionStrategy()));						

				} else {
					
					_log.trace("Incompatible via Class vs. Primitive array type");
					return false;
				}
					
			} else {
				
				_log.trace("Unnecessary reference types used. Unwrapping reference types and re-checking...");
				
				// Consider the ReferenceType as an insignificant wrapper. Just unwrap and re-check
				return checkArgumentCompatibility(
						true,
						new SimpleResolvableType(paramReferenceType.getType(), param.getResolutionStrategy()),
						new SimpleResolvableType(argReferenceType.getType(), arg.getResolutionStrategy()));
			}

		} else if (paramType instanceof ClassOrInterfaceType && argType instanceof ClassOrInterfaceType) {
			
			_log.trace("Comparing class or interface types");
			
			TypeDeclaration paramTypeDef = ClassLoader.getRequiredDefinition(param.getQualifiedType());
			TypeDeclaration callParamTypeDef = ClassLoader.getRequiredDefinition(arg.getQualifiedType());
			
			if (paramTypeDef instanceof EnumDeclaration || callParamTypeDef instanceof EnumDeclaration) {
				if (!paramTypeDef.equals(callParamTypeDef)) {
					_log.trace("Incompatible via Enum equality");
				}
			} else if (considerTypeInheritance) {
				if (!ClassLoader.checkSubclassInference((ClassOrInterfaceDeclaration)callParamTypeDef, (ClassOrInterfaceDeclaration)paramTypeDef)) {
					_log.trace("Incompatible via type inheritance");
					return false;
				}
			} else {
				if (!callParamTypeDef.equals(paramTypeDef)) {
					_log.trace("Incompatible via precise type match");
					return false;
				}
			}

		} else if (paramType instanceof PrimitiveType && argType instanceof PrimitiveType) {
			
			_log.trace("Comparing primitive types");
			
			//_log.info("### Primitive parameter comparison: ");				
			
			// Primitives
			// TODO: implement more advanced primitive compatibility check
			
			try {
				
				if (((PrimitiveType)paramType).getType().equals(Primitive.Long) 
						&& ((PrimitiveType)argType).getType().equals(Primitive.Int)) {
					
					_log.trace("WORKAROUND BEFORE TYPE WIDENING SUPPORT: Arguments of type int are compatible with parameters of type long");					
				
				} else if (((PrimitiveType)paramType).getType().equals(Primitive.Int) 
						&& ((PrimitiveType)argType).getType().equals(Primitive.Char)) {
					
					_log.trace("WORKAROUND BEFORE TYPE WIDENING SUPPORT: Arguments of type char are compatible with parameters of type int");
					
				} else  if (!((PrimitiveType)paramType).equals((PrimitiveType)argType)) {
				
					_log.trace("Primitive types not compatible");
					return false;
				}
				
			} catch (ClassCastException e) {
				_log.info(arg.getClass().getName());
				throw e;
			}
			
		} else if (paramType instanceof ReferenceType && argType instanceof UnknownType) {
			
			// Null arguments are unknown types and compatible with any reference type parameter				
		
		} else if ((paramType instanceof ReferenceType && argType instanceof PrimitiveType)) {
			
			_log.trace("Autoboxing argument primitive type");
			
			return checkArgumentCompatibility(
					considerTypeInheritance,
					param,
					new SimpleResolvableType(getAutoboxedPrimitive((PrimitiveType)argType), arg.getResolutionStrategy()));
			
			
		} else if ((paramType instanceof PrimitiveType && argType instanceof ReferenceType)) {
			
			_log.trace("Autoboxing parameter primitive type");
			
			return checkArgumentCompatibility(
					considerTypeInheritance,
					new SimpleResolvableType(getAutoboxedPrimitive((PrimitiveType)paramType), param.getResolutionStrategy()),
					arg);
			
		} else {
			
			_log.trace("Incompatible reference type vs. primitive. Parameter type is " + paramType.getClass().getName() + " and argument type is " + argType.getClass().getName());
			return false;
		}
		
		return true;
	}
		
	
    private static ReferenceType getAutoboxedPrimitive(PrimitiveType primitiveType) {
    	
    	ReferenceType retType;
    	
    	switch (primitiveType.getType()) {
	    	case Boolean: retType = ASTHelper.createReferenceType("java.lang.Boolean", 0); break;
	    	case Char: retType = ASTHelper.createReferenceType("java.lang.Character", 0); break;
	    	case Byte: retType = ASTHelper.createReferenceType("java.lang.Byte", 0); break;
	    	case Short: retType = ASTHelper.createReferenceType("java.lang.Short", 0); break;
	    	case Int: retType = ASTHelper.createReferenceType("java.lang.Integer", 0); break;
	    	case Long: retType = ASTHelper.createReferenceType("java.lang.Long", 0); break;
	    	case Float: retType = ASTHelper.createReferenceType("java.lang.Float", 0); break;
	    	case Double: retType = ASTHelper.createReferenceType("java.lang.Double", 0); break;
	    	default: retType = null;
    	}
    	
    	if (retType != null) {
    		retType.setParentNode(primitiveType.getParentNode());
    		retType.getType().setParentNode(retType);
    	}
    	
    	return retType;
    }
	
	
    public static List<MethodDeclaration> findBestMatchMethodDeclaration(
    			ResolvableType callScopeType,
    			boolean isStaticCall,
    			String methodName,
    			ResolvableType[] callParamTypes
    		) {
    	
    	_log.info("Searching for methods with signature: " + JavaLangUtils.getMethodSignatureString(methodName, callParamTypes));
    	
    	List<MethodDeclaration> candidateMethods;
    	
    	ClassOrInterfaceDeclaration scopeTypeDeclaration;
    	SymbolTable scopeTypeSymbolTable;
    	
    	//_log.info("Invocation object: " + object);
    	if (isStaticCall) {
    		
    		_log.info("Static call");
    		List<MethodDeclaration> methods = null; // TODO: Handle static invocation
    		
    		throw new RuntimeException("findBestMatchMethodDeclaration missing support static invocation");
    		
    	} else {
    			
    		if (callScopeType != null && !(callScopeType.getType() instanceof VoidType)) {
    			
    			_log.info("Invocation object type: " + callScopeType.getQualifiedType()); //symbolTable.resolveType(callScopeType.toString()));
				scopeTypeDeclaration = (ClassOrInterfaceDeclaration)ClassLoader.getRequiredDefinition(callScopeType.getQualifiedType()); //symbolTable.resolveType(callScopeType.toString()));
				
				_log.info("Retrieved ClassOrInterfaceDeclaration");
				
				scopeTypeSymbolTable = SymbolTable.getSymbolTableForClassOrInterface(scopeTypeDeclaration, callScopeType.getTypeArgs());
				
				//_log.info("Scope object's SymbolTable:");
				//_log.info(scopeTypeSymbolTable.toString());
				
				List<MethodDeclaration> methods = scopeTypeSymbolTable.getMethodDeclaration(methodName);
				
				_log.debug("Found " + methods.size() + " methods named " + methodName + " on type " + callScopeType.toString());
				
				candidateMethods = getCompatibleMethods(callParamTypes, methods);
				
				if (candidateMethods != null && candidateMethods.size() > 0 ) {
					
					StringBuffer sb = new StringBuffer();
					for (MethodDeclaration method : candidateMethods) {
						sb.append(' ');
						sb.append(JavaLangUtils.getMethodSignatureString(method));
					}
					_log.info("Compatible methods for invocation:" + sb.toString());
				}
			
    		} else {
    			
    			
    			throw new RuntimeException("Should be treating local invocation as scoped invocation. Provide a scope type.");
    			
    			//_log.info("local method invocation");
    			//List<MethodDeclaration> methods = symbolTable.getMethodDeclaration(methodName);
    			
    			//candidateMethods = getCompatibleMethods(callParamTypes, symbolTable, methods, symbolTable);
    		}
    	}
    	
    	if (candidateMethods == null || candidateMethods.size() == 0) {
    		_log.error("No matching methods found");
    		_log.debug("Scope type symbol table follows:\n" + scopeTypeSymbolTable.toString());
    		return null;
    	}
    	
    	
    	List<MethodDeclaration> mostSpecificMethods = new LinkedList<MethodDeclaration>();    	
    	MethodDeclaration mostSpecificMethod = findMostSpecificMethod(candidateMethods);
		
		_log.info("Most specific methods for invocation: " + JavaLangUtils.getMethodSignatureString(mostSpecificMethod));

		mostSpecificMethods.add(mostSpecificMethod);    	
    	return mostSpecificMethods;
    }
    
    private static MethodDeclaration findMostSpecificMethod(List<MethodDeclaration> methods) {
    	
    	if (methods == null) return null;
    	if (methods.size() == 1) {
    		_log.debug("Most specific method found: " + JavaLangUtils.getMethodSignatureString(methods.get(0)));
    		return methods.get(0);
    	}
    	
    	MethodDeclaration checkMethodDeclaration = methods.get(0);
    	List<MethodDeclaration> checkAgainstList = methods.subList(1, methods.size());
    	
    	_log.trace("Checking compatibility of " + JavaLangUtils.getMethodSignatureString(checkMethodDeclaration) + " ...");
    	
    	//List<MethodDeclaration> resultsList = new LinkedList<MethodDeclaration>();
    	
    	for (MethodDeclaration methodDeclaration : checkAgainstList) {
    	
    		_log.trace("... with " + JavaLangUtils.getMethodSignatureString(methodDeclaration));
    		
    		SymbolTable methodSymbolTable = SymbolTable.getSymbolTableForMethod(methodDeclaration);
    		
    		boolean compatible = checkArgumentsCompatibility(
    					SimpleResolvableType.getResolvableTypeListFromParameters(checkMethodDeclaration.getParameters(), methodSymbolTable)
    							.toArray(new ResolvableType[checkMethodDeclaration.getParameters().size()]),
    					methodDeclaration.getParameters(),
    					true);
    		
    		if (!compatible) {
    	
    			_log.trace(" ... " + JavaLangUtils.getMethodSignatureString(checkMethodDeclaration) + " is compatible with " + JavaLangUtils.getMethodSignatureString(methodDeclaration));
    			// Discard checkMethod as less specific and recursively check the rest of the methods
    			return findMostSpecificMethod(checkAgainstList);
    		}
    	}
    	
    	_log.trace(JavaLangUtils.getMethodSignatureString(checkMethodDeclaration) + " ... is not compatible with all methods");
    	
    	// If the checkMethod is not compatible with any other the others, so it is the most specific 
    	return checkMethodDeclaration;
    }
    
    private final static org.slf4j.Logger _log = LoggerFactory.getLogger(StaticAnalysisUtils.class);
}
