package com.liferay.tools.security.symbol.resolution.strategy;

import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;

import org.slf4j.LoggerFactory;

import com.github.javaparser.ASTHelper;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.ImportDeclaration;
import com.github.javaparser.ast.Node;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.TypeDeclaration;
import com.liferay.tools.security.LiferayCodeAnalytics;
import com.liferay.tools.security.LiferayCodeVisitor;
import com.liferay.tools.security.ClassLoader;
import com.liferay.tools.security.symbol.SymbolTable;
import com.liferay.tools.security.symbol.UnresolvableSymbolException;
import com.liferay.tools.security.symbol.SymbolTable.ResolutionStrategyOrchestrator;

public class CompilationUnitResolutionStrategyImpl implements ResolutionStrategy {

	CompilationUnit _cu;
	private Map<String, String> _localCUSymbols;
	
	public CompilationUnitResolutionStrategyImpl(CompilationUnit cu) {
		_cu = cu;
	}
	
	Set<String> javaLangImplicit = new HashSet<String>(Arrays.asList(new String[] 
			{"System", "String", "Object", "Override", "Exception", "ThreadLocal", "Throwable", "Cloneable", "Long", 
			"ClassLoader", "Class", "Boolean", "RuntimeException", "Thread", "Iterable", "Integer", "Comparable",
			"UnsupportedOperationException", "IllegalArgumentException", "Double", "Float", "Short", "Number", "AutoCloseable", "Math", "Deprecated",
			"Void"}));	
	
	private Map<String, String> getLocalCUSymbolsMap() {
		
		if (_localCUSymbols == null) {
			initialiseLocalCUSymbolsMap();
		}
		
		return _localCUSymbols;
	}
	
	private void initialiseLocalCUSymbolsMap() {
		
		_localCUSymbols = new HashMap<String, String>();
		
		LiferayCodeVisitor classDeclarationVisitor = new LiferayCodeVisitor() {
			
			public void visit(ClassOrInterfaceDeclaration node, LiferayCodeAnalytics arg) {

				StringBuffer outerScopeStr = new StringBuffer();
								
				// Handle inner classes. Ensure they are loaded as {PackageName}.{OuterClass}.{InnerClassName}
				Node outerScope = node;
				while ((outerScope = outerScope.getParentNode()) instanceof ClassOrInterfaceDeclaration) {
					outerScopeStr.insert(0, ((ClassOrInterfaceDeclaration)outerScope).getName());
					outerScopeStr.insert(0, '.');
				}
				
				String qualifiedClassName = _cu.getPackage().getName().toString() + outerScopeStr.toString() + "." + node.getName();
				
				_localCUSymbols.put(node.getName(), qualifiedClassName);

				super.visit(node, arg);
			}
		};
		classDeclarationVisitor.visit(_cu, null);
	}
	
	/*
	 * Attempt to resolve a symbol into a type by looking at imports
	 * and classes loaded from the package declared in the compilation unit
	 */
	//private String resolveConcreteType(String symbol) throws UnresolvableSymbolException {
	public String resolveType(String symbol) throws UnresolvableSymbolException {
				
		_log.trace("resolveSymbol(\"" + symbol + "\")");
		
		if (symbol.indexOf('.') != -1) {
		
			// The symbol may already have been resolved...
			if (ClassLoader.getDefinition(symbol) != null) {
				_log.trace("Resolved via ClassLoader.getDefinition()");
				return symbol;
			}
			
			// Or it may be referring to an inner class of a class in the same package 
			// that could be referred to directly without import 
			_log.trace("Checking if the symbol is relative to a resolvable class...");
			return resolveType(symbol.substring(0, symbol.lastIndexOf('.'))) + symbol.substring(symbol.lastIndexOf('.'));
		}
		
		if (getLocalCUSymbolsMap().keySet().contains(symbol)) {
			_log.trace("Resolved via CU member");
			return getLocalCUSymbolsMap().get(symbol);
		}
				
		if (javaLangImplicit.contains(symbol)) return "java.lang." + symbol;
		
		List<ImportDeclaration> importDeclarations = _cu.getImports();
		
		if (_cu.getImports() != null) {
			
			for (ImportDeclaration importDeclaration : importDeclarations) {
				
				// Handle wildcard imports
				if (importDeclaration.isAsterisk()) {
					
					String potenticalClass = importDeclaration.getName().toString() + "." + symbol;
					
					if (ClassLoader.getDefinition(potenticalClass) != null) {
						_log.trace("Resolved through wildcard import: " + potenticalClass);
						return potenticalClass;
					}
					
				} else {
				
					// Get the unqualified name from the import statement
					String importSymbol = importDeclaration.getName().getName();
					
					if (importSymbol.equals(symbol)) {
						_log.trace("Resolved through specific import: " + importDeclaration.getName().toString());
						return importDeclaration.getName().toString();
					}
				}
			}
		}
		
		// Check if it's a class in the local package
		String candidateClassName = _cu.getPackage().getName().toString() + "." + symbol;
		
		TypeDeclaration def = ClassLoader.getDefinition(candidateClassName);
		
		if (def != null) {
			_log.trace("Resolved through local package: " + candidateClassName);
			return candidateClassName;
		}
			
		throw new UnresolvableSymbolException(symbol);
	}
	
	private final static org.slf4j.Logger _log = LoggerFactory.getLogger(CompilationUnitResolutionStrategyImpl.class);
}
