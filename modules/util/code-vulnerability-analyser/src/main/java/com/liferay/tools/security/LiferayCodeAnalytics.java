package com.liferay.tools.security;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.slf4j.LoggerFactory;

import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.body.Parameter;
import com.github.javaparser.ast.body.TypeDeclaration;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.ast.type.ReferenceType;
import com.github.javaparser.ast.type.Type;
import com.liferay.tools.security.symbol.SymbolTable;
import com.liferay.tools.security.symbol.resolution.ImplsAwareType;
import com.liferay.tools.security.symbol.resolution.InlineImplsAwareType;
import com.liferay.tools.security.utils.JavaLangUtils;
import com.liferay.tools.security.utils.StaticAnalysisUtils;

public class LiferayCodeAnalytics {

	private Map<SymbolTable<MethodDeclaration>, List<MethodCallExpr>> _invocationExprs =
			new HashMap<SymbolTable<MethodDeclaration>, List<MethodCallExpr>>();
	
	// A Map of method signatures to method "mocks".
	// Method signatures are Strings in the format: {package}.{class}#{method}({type},{type})
	// Each "mock" is implemented as a Map where the values are ImplsAwareType representing return types
	// and the keys are instances of MethodInvocationArgs
	private Map<String, Map<MethodInvocationArgs, ImplsAwareType>> _mocksMethods =
			new HashMap<String, Map<MethodInvocationArgs, ImplsAwareType>>();
	
	private Map<SymbolTable<MethodDeclaration>, Map<MethodInvocationArgs, ImplsAwareType>> _methodsInvocations = 
			new HashMap<SymbolTable<MethodDeclaration>, Map<MethodInvocationArgs, ImplsAwareType>>();

	private List<String> _warnings = new LinkedList<String>();
	
	
	public void addMock(String methodSignature, Map<MethodInvocationArgs, ImplsAwareType> mock) {
		_mocksMethods.put(methodSignature, mock);
	}
	
	
	public Set<SymbolTable<MethodDeclaration>> getMethodDeclarations() {
		return new HashSet<SymbolTable<MethodDeclaration>>(_methodsInvocations.keySet());
	}
	
	public Map<MethodInvocationArgs, ImplsAwareType> getInvocations(SymbolTable<MethodDeclaration> methodST) {
		return getInvocations(methodST, false);
	}
	
	private Map<MethodInvocationArgs, ImplsAwareType> getInvocations(SymbolTable<MethodDeclaration> methodST, boolean createMapIfNull) {
		Map<MethodInvocationArgs, ImplsAwareType> ret = _methodsInvocations.get(methodST);
		
		if (ret == null) {
			ret = new HashMap<MethodInvocationArgs, ImplsAwareType>();
			if (createMapIfNull) _methodsInvocations.put(methodST, ret);
		}
		
		return ret;
	}
	
	public List<MethodCallExpr> getInvocationExprs(SymbolTable<MethodDeclaration> method) {
		return getInvocationExprs(method, false);
	}

	private List<MethodCallExpr> getInvocationExprs(SymbolTable<MethodDeclaration> method, boolean createMapIfNull) {
		List<MethodCallExpr> ret = _invocationExprs.get(method);
		
		if (ret == null) {
			ret = new LinkedList<MethodCallExpr>();
			if (createMapIfNull) _invocationExprs.put(method, ret);
		}
		
		return ret;
	}

	public ImplsAwareType getRegisteredMethodInvocationReturn(SymbolTable<MethodDeclaration> methodST, MethodInvocationArgs invocation) {
		
		_log.trace("isMethodInvocationRegistered()");
		_log.trace(" Arg method = " + JavaLangUtils.getMethodSignatureString(methodST.getNode()));
		_log.trace(" Arg invocation = " + invocation.toString());
		
		
		
		_log.trace("isMethodInvocationRegistered() returning " + getInvocations(methodST, false).keySet().contains(invocation));
		
		for (MethodInvocationArgs previousInvocationArgs : getInvocations(methodST, false).keySet()) {
			
			if (previousInvocationArgs.encompasses(invocation))
				return getInvocations(methodST, false).get(previousInvocationArgs);
		}
		
		return getMockedReturn(methodST, invocation);
	}


	private ImplsAwareType getMockedReturn(SymbolTable<MethodDeclaration> methodST,
			MethodInvocationArgs invocationArgs) {
		String relatedClassName = SymbolTable.getSymbolTableForMethod(methodST.getNode()).resolveType(StaticAnalysisUtils.getClassDeclaration(methodST.getNode()).getName());
		
		String mockKey = relatedClassName + "#" + JavaLangUtils.getMethodSignatureString(methodST.getNode());
		Map<MethodInvocationArgs, ImplsAwareType> mock = _mocksMethods.get(mockKey);
		if (mock != null) {
			
			_log.debug("Found a mock matching class + method signature: " + mockKey);
			
			for (MethodInvocationArgs mockedArgs : mock.keySet()) {
				
				_log.debug("Checking relevance of mocked argument: " + mockedArgs.toString());

				if (mockedArgs.encompasses(invocationArgs)) {
					
					_log.debug("Mocked arguments are relevant!");
					ImplsAwareType mockedReturn = mock.get(mockedArgs);
					
					return mockedReturn;
				}
			}
		}
		
		return null;
	}
	
	public void registerMethodInvocation(MethodCallExpr callingExpr, SymbolTable<MethodDeclaration> methodST, MethodInvocationArgs invocationArgs, ImplsAwareType returnType) {		
		
		List<MethodCallExpr> invocationExprs = getInvocationExprs(methodST, true);
		if (!invocationExprs.contains(callingExpr)) {
			invocationExprs.add(callingExpr);
		}
		
		getInvocations(methodST, true).put(invocationArgs, returnType);
		
		StringBuffer sb = new StringBuffer();
	
		if (returnType != null) {
			sb.append(returnType.serialize());
			sb.append(' ');
		}
		
		sb.append(methodST.getNode().getName());
		sb.append('(');
		
		SymbolTable<? extends TypeDeclaration> methodClassSymbolTable = methodST.getTypeDeclarationSymbolTable();
		
		if (invocationArgs != null && invocationArgs.size() > 0) {
			
			Iterator<Parameter> i = methodST.getNode().getParameters().iterator();
			
			for (ImplsAwareType type : invocationArgs) {
				
				Parameter param = i.next();
				if (type.getType() instanceof ReferenceType) {
					
					
					if (param.getType() instanceof ReferenceType) {
						//sb.append(new InlineImplsAwareType((ReferenceType)param.getType(), methodClassSymbolTable, type.getPossibleImplTypes()).serialize());
						sb.append(new InlineImplsAwareType((ReferenceType)param.getType(), methodST, type.getPossibleImplTypes()).serialize());
					} else {
						//InlineImplsAwareType inlineImplsAwareType = new InlineImplsAwareType(param.getType(), methodClassSymbolTable);
						InlineImplsAwareType inlineImplsAwareType = new InlineImplsAwareType(param.getType(), methodST);
						inlineImplsAwareType.addPossibleImplTypes(type.getPossibleImplTypes());
						sb.append(inlineImplsAwareType.serialize());
					}
					
				} else {
					//sb.append(new InlineImplsAwareType(param.getType(), methodClassSymbolTable).serialize());	
					sb.append(new InlineImplsAwareType(param.getType(), methodST).serialize());
				}
				sb.append(',');
			}
			sb.deleteCharAt(sb.length() - 1);
		}
		sb.append(')');
		
		_log.info("LiferayCodeAnalytics :: " + sb.toString());
	}
	
	public void addWarning(String warning) {
		_warnings.add(warning);
	}
	
	public List<String> getWarnings() {
		return _warnings;
	}
	
	public void onMethodInvoked(
			MethodCallExpr callExpr, 
			ImplsAwareType callScopeType, 
			MethodDeclaration method, 
			List<ImplsAwareType> paramImpls) {
		
		
		
	}
	
	private final static org.slf4j.Logger _log = LoggerFactory.getLogger(LiferayCodeAnalytics.class);
}
