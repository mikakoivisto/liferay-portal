package com.liferay.tools.security.symbol;

import java.util.LinkedList;
import java.util.List;

import com.github.javaparser.ASTHelper;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.TypeParameter;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.body.TypeDeclaration;
import com.liferay.tools.security.symbol.resolution.ResolvableType;
import com.liferay.tools.security.symbol.resolution.SimpleResolvableType;
import com.liferay.tools.security.symbol.resolution.strategy.ResolutionStrategy;

public class TypeDeclarationSymbolTableKey implements SymbolTableKey {

	private TypeDeclaration _def;
	private List<ResolvableType> _typeArgs;
	
	private SymbolTableKey _outerScopeSymbolTableKey;
	
	private String _cachedSerialization;

	
	public TypeDeclarationSymbolTableKey(ClassOrInterfaceDeclaration def, List<ResolvableType> typeArgs) {
		this(def, typeArgs, null);
	}
	
	public TypeDeclarationSymbolTableKey(ClassOrInterfaceDeclaration def, List<ResolvableType> typeArgs, SymbolTableKey outerScopeSymbolTableKey) {
		
		_def = def;
		_typeArgs = typeArgs;
		_outerScopeSymbolTableKey = outerScopeSymbolTableKey;
	}
	
	public TypeDeclarationSymbolTableKey(ClassOrInterfaceDeclaration def, ResolutionStrategy resolutionStrategy, SymbolTableKey outerScopeSymbolTableKey) {
		
		if (def.getTypeParameters() != null && def.getTypeParameters().size() > 0) {
			_typeArgs = new LinkedList<ResolvableType>();
			
			for (TypeParameter typeParam : def.getTypeParameters()) {
				
				try {
					_typeArgs.add(new SimpleResolvableType(
							ASTHelper.createReferenceType(resolutionStrategy.resolveType(typeParam.getName()), 0), 
							resolutionStrategy));
					
				} catch (UnresolvableSymbolException e) {
					e.printStackTrace();
				}
			}
			
		} else {
			_typeArgs = null;
		}
	}
	
	/* (non-Javadoc)
	 * @see com.liferay.tools.security.symbol.SymbolTableKey#serialize()
	 */
	public String serialize() {
		
		if (_cachedSerialization != null) return _cachedSerialization;
		
		StringBuffer sb = new StringBuffer();
		
		if (_outerScopeSymbolTableKey != null) {
			sb.append(_outerScopeSymbolTableKey.serialize());
			sb.append('/');
		}
		
		CompilationUnit cu = com.liferay.tools.security.ClassLoader.getCompilationUnit(_def);
		
		String packageName;
		if (cu.getPackage() != null) {		
			packageName = cu.getPackage().getName().toString();
			sb.append(packageName);
			sb.append('.');
		} else {
			packageName = null;
		}
		
		sb.append(_def.getName());
		
		if (_typeArgs != null && _typeArgs.size() > 0) {
			
			sb.append('<');
			
			for (ResolvableType typeArg : _typeArgs) {
				
				if (typeArg.isUnknownType()) {
					sb.append('?');
				} else {
					sb.append(typeArg.getQualifiedType());
				}
				sb.append(',');
			}
			sb.deleteCharAt(sb.length() - 1);
			
			sb.append('>');
		}
		
		_cachedSerialization = sb.toString();
		
		return _cachedSerialization;
	}
	
	/* (non-Javadoc)
	 * @see com.liferay.tools.security.symbol.SymbolTableKey#hashCode()
	 */
	@Override
	public int hashCode() {
		return serialize().hashCode();
	}
	
	/* (non-Javadoc)
	 * @see com.liferay.tools.security.symbol.SymbolTableKey#equals(java.lang.Object)
	 */
	@Override
	public boolean equals(Object obj) {

		if (obj instanceof TypeDeclarationSymbolTableKey) {
			return serialize().equals(((SymbolTableKey)obj).serialize());
		}
		return false;
	}
	
	@Override
	public String toString() {
		return serialize();
	}
}
