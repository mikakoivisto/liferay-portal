package com.liferay.tools.security;

import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Stack;

import org.slf4j.LoggerFactory;

import com.github.javaparser.ASTHelper;
import com.github.javaparser.ast.Node;
import com.github.javaparser.ast.body.AnnotationMemberDeclaration;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.EnumDeclaration;
import com.github.javaparser.ast.body.FieldDeclaration;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.body.MultiTypeParameter;
import com.github.javaparser.ast.body.Parameter;
import com.github.javaparser.ast.body.TypeDeclaration;
import com.github.javaparser.ast.body.VariableDeclarator;
import com.github.javaparser.ast.expr.AnnotationExpr;
import com.github.javaparser.ast.expr.ArrayAccessExpr;
import com.github.javaparser.ast.expr.ArrayCreationExpr;
import com.github.javaparser.ast.expr.ArrayInitializerExpr;
import com.github.javaparser.ast.expr.AssignExpr;
import com.github.javaparser.ast.expr.BinaryExpr;
import com.github.javaparser.ast.expr.BooleanLiteralExpr;
import com.github.javaparser.ast.expr.CastExpr;
import com.github.javaparser.ast.expr.CharLiteralExpr;
import com.github.javaparser.ast.expr.ClassExpr;
import com.github.javaparser.ast.expr.ConditionalExpr;
import com.github.javaparser.ast.expr.DoubleLiteralExpr;
import com.github.javaparser.ast.expr.EnclosedExpr;
import com.github.javaparser.ast.expr.Expression;
import com.github.javaparser.ast.expr.FieldAccessExpr;
import com.github.javaparser.ast.expr.InstanceOfExpr;
import com.github.javaparser.ast.expr.IntegerLiteralExpr;
import com.github.javaparser.ast.expr.IntegerLiteralMinValueExpr;
import com.github.javaparser.ast.expr.LambdaExpr;
import com.github.javaparser.ast.expr.LongLiteralExpr;
import com.github.javaparser.ast.expr.LongLiteralMinValueExpr;
import com.github.javaparser.ast.expr.MarkerAnnotationExpr;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.ast.expr.MethodReferenceExpr;
import com.github.javaparser.ast.expr.NameExpr;
import com.github.javaparser.ast.expr.NormalAnnotationExpr;
import com.github.javaparser.ast.expr.NullLiteralExpr;
import com.github.javaparser.ast.expr.ObjectCreationExpr;
import com.github.javaparser.ast.expr.QualifiedNameExpr;
import com.github.javaparser.ast.expr.SingleMemberAnnotationExpr;
import com.github.javaparser.ast.expr.StringLiteralExpr;
import com.github.javaparser.ast.expr.SuperExpr;
import com.github.javaparser.ast.expr.ThisExpr;
import com.github.javaparser.ast.expr.TypeExpr;
import com.github.javaparser.ast.expr.UnaryExpr;
import com.github.javaparser.ast.expr.VariableDeclarationExpr;
import com.github.javaparser.ast.stmt.BlockStmt;
import com.github.javaparser.ast.stmt.CatchClause;
import com.github.javaparser.ast.stmt.ExpressionStmt;
import com.github.javaparser.ast.stmt.ReturnStmt;
import com.github.javaparser.ast.type.ClassOrInterfaceType;
import com.github.javaparser.ast.type.PrimitiveType;
import com.github.javaparser.ast.type.PrimitiveType.Primitive;
import com.github.javaparser.ast.type.ReferenceType;
import com.github.javaparser.ast.type.Type;
import com.github.javaparser.ast.type.UnknownType;
import com.liferay.tools.security.symbol.SymbolTable;
import com.liferay.tools.security.symbol.SymbolTable.Entry;
import com.liferay.tools.security.symbol.resolution.ImplsAwareType;
import com.liferay.tools.security.symbol.resolution.InlineImplsAwareType;
import com.liferay.tools.security.symbol.resolution.ResolvableType;
import com.liferay.tools.security.symbol.resolution.SimpleResolvableType;
import com.liferay.tools.security.utils.JavaLangUtils;
import com.liferay.tools.security.utils.StaticAnalysisUtils;

public class ExpressionVisitor extends LiferayCodeVisitor {
	
	private int _indentLvl = 0;
	private Stack<ImplsAwareType> _exprType = new Stack<ImplsAwareType>();
	
	protected SymbolTable<?> _currentSymbolTable;
	
	private void ensureReadyToAnalyse(Node node) {
		if (_currentSymbolTable == null) {
			_currentSymbolTable = SymbolTable.getSymbolTable(node);
		}
	}
	
	public ImplsAwareType getExprType() {
		return peekType();
	}
	
	private ImplsAwareType peekType() {
		_log.info(getIndent() + "<-- Peeking " + _exprType.peek().getClass().getName() + " impl with type: " + _exprType.peek().serialize());
		return _exprType.peek();
	}

	private ImplsAwareType popType() {
		_log.info(getIndent() + "<-- Popping " + _exprType.peek().getClass().getName() + " impl with type: " + _exprType.peek().serialize());
		return _exprType.pop();
	}

	private void pushType(ImplsAwareType type) {
		_log.info(getIndent() + "--> Pushing " + type.getClass().getName() + " impl with type: " + type.serialize());
        _exprType.push(type);
	}
		
	private void logGeneric(Node n) {
		
		String indent = getIndent();
		
		_log.info(indent + "####################");
		_log.info(indent + n.getClass().getName());
		_log.info(indent + "Position " + n.getBeginLine() + ":" + n.getBeginColumn() + " of " + StaticAnalysisUtils.getClassDeclaration(n).getName() + ":");
		_log.info(indent + n.toString());
		_log.info("");
	}
	
	private String getIndent() {
		StringBuffer indent = new StringBuffer();
		indent.append(_indentLvl);
		indent.append(' ');
		
		for (int i = 0; i < _indentLvl; i++) {
			indent.append(' ');
		}
		return indent.toString();
	}
	
	
	@Override
	public void visit(ClassOrInterfaceDeclaration node, LiferayCodeAnalytics arg) {
		
		ensureReadyToAnalyse(node);
		
		_currentSymbolTable = SymbolTable.getSymbolTableForClassOrInterface(node);
		super.visit(node, arg);
	}
	
	
	private MethodInvocationArgs _currentInvocationArgsList;

	@Override
    public void visit(MethodCallExpr node, LiferayCodeAnalytics arg) {
    	
		logGeneric(node);
		ensureReadyToAnalyse(node);
		     	
        String methodName = node.getName();
        List<Expression> args = node.getArgs();
        
        ImplsAwareType[] implsAwareArgTypes = new ImplsAwareType[(args != null ? args.size() : 0)];
        
        // Continue visiting the method call parameter expressions
        // Their types will be added to the Stack
        
        ImplsAwareType scopeImplsAwareType;
		if (node.getScope() != null) {
			
			_log.info(getIndent() + "MethodCallExpr scope found: " + node.getScope().toString());

			_indentLvl++;
			node.getScope().accept(this, arg);
			_indentLvl--;
			
			// someMethod() should have pushed its return type
			scopeImplsAwareType = popType();
			_log.info(getIndent() + "Scope type is " + scopeImplsAwareType.getClass().getName() + ": " + scopeImplsAwareType.serialize());
						
		} else {
			
			_log.info(getIndent() + "MethodCallExpr without scope");
						
			ClassOrInterfaceDeclaration currentClassDef = StaticAnalysisUtils.getClassDeclaration(node);
			scopeImplsAwareType = new InlineImplsAwareType(
					ASTHelper.createReferenceType(currentClassDef.getName(), 0),
					_currentSymbolTable.getTypeDeclarationSymbolTable(), 
					_currentSymbolTable.getTypeDeclarationSymbolTable()
					);
			
			_log.info(getIndent() + "Setting scope to local class: " + scopeImplsAwareType.getQualifiedType());
		}
		
		int i = 0;
		if (node.getArgs() != null) {
			for (final Expression e : node.getArgs()) {
				_log.info(getIndent() + "Analysing argument expression: " + e.toString());
				
				_indentLvl++;
				e.accept(this, arg);
				_indentLvl--;
				
				// After visiting expressions, pop their types from the Stack
				implsAwareArgTypes[i] = popType();
				i++;
			}
		}
		        
        for (MethodDeclaration method : StaticAnalysisUtils.findBestMatchMethodDeclaration(
        			(scopeImplsAwareType != null ? scopeImplsAwareType : null),
        			false, 
        			methodName, 
        			implsAwareArgTypes)
        		) {
        
	        if (method != null) {
	    
	        	MethodInvocationArgs methodArgs = new MethodInvocationArgs(Arrays.asList(implsAwareArgTypes));
	        	MethodDeclaration methodImpl;
	        	
	        	if (scopeImplsAwareType != null) {
	        		
		        	if (scopeImplsAwareType.getPossibleImplTypes() == null || scopeImplsAwareType.getPossibleImplTypes().size() == 0) {
		        		
		        		String warning = getNoKnownImplTypesMsg(node, scopeImplsAwareType, method);
		        		_log.warn(getIndent() + warning);
		        		
		        		// Register this warning into the LiferayCodeAnalytics as well
		        		arg.addWarning(warning);
		        		
		        		// Normally visiting the MethodDeclaration on the scope object will push the return type
		        		// So even though this is not available, a push must be made
		        		
		        		// Retrieve the SymbolTable for the implementation MethodDeclaration, taking into account type arguments for both the class and method
		        		SymbolTable<MethodDeclaration> methodST = buildMethodDeclarationSymbolTable(node, scopeImplsAwareType, method);
		        		
		        		pushType(new InlineImplsAwareType(method.getType(), methodST));
		        		
		        	} else {
		        	
	        			StringBuffer sb = new StringBuffer();
	        			for (SymbolTable<? extends TypeDeclaration> def : scopeImplsAwareType.getPossibleImplTypes()) {
		        			sb.append(def.getNode().getName());
		        			sb.append(',');
		        		}
		        		sb.deleteCharAt(sb.length() - 1);
		        		_log.info(getIndent() + "Will visit the method on all possible scope objects impls: " + sb.toString());
	        		
			        	for (SymbolTable<? extends TypeDeclaration> scopeImplType : scopeImplsAwareType.getPossibleImplTypes()) {
			        		
			        		_log.info("Preparing to visit method " + method.getName() + " on scope object impls: " + scopeImplType.getNode().getName());
			        		
			        		methodImpl = StaticAnalysisUtils.getMethodImpl(method, scopeImplType.getNode());

			        		// Retrieve the SymbolTable for the implementation MethodDeclaration, taking into account type arguments for both the class and method
			        		SymbolTable<MethodDeclaration> methodST = buildMethodDeclarationSymbolTable(node, scopeImplsAwareType, methodImpl);
			        		
			        		ImplsAwareType registeredReturn = arg.getRegisteredMethodInvocationReturn(methodST, methodArgs);
			        		if (registeredReturn != null) {
			        			_log.info(getIndent() + "Not visiting " + method.getName() + " on class " + scopeImplType.getNode().getName() + ". Already visited, or mocked.");
			        			
			        			// Still need record the fact that there was an invocation from this expression
			        			arg.registerMethodInvocation(node, methodST, methodArgs, registeredReturn);
			        			
			        			pushType(registeredReturn);
			        			continue;
			        		}
			        		
			        		_log.info(getIndent() + "Visiting method \"" + method.getName() + "\" on class " + scopeImplType.getNode().getName());
			        		arg.registerMethodInvocation(node, methodST, methodArgs, new InlineImplsAwareType(method.getType(), SymbolTable.getSymbolTableForMethod(method)));

			        		SymbolTable<?> resumeSymbolTable = _currentSymbolTable;
			        		_currentSymbolTable = methodST;

			        		// Visit the method
			        		
			        		MethodInvocationArgs resumeInvocationArgsList = _currentInvocationArgsList;
			        		_currentInvocationArgsList = methodArgs;
			        		
				        	_indentLvl++;
					        visit(methodImpl, arg);
					        _indentLvl--;
					        
					        _currentSymbolTable = resumeSymbolTable;
					        _currentInvocationArgsList = resumeInvocationArgsList;
					        
					        _log.info(getIndent() + "Returned from visiting method \"" + method.getName() + "\" on class " + scopeImplType.getNode().getName());
					        arg.registerMethodInvocation(node, methodST, methodArgs, peekType());
			        	}
		        	}
	        	
	        	} else {
	        		
	        		// Local method invocation
	        		_log.info(getIndent() + "Visiting local method " + method.getName());
	        		
	        		methodImpl = method;

			        // Visit the method
		        	_indentLvl++;
			        visit(methodImpl, arg);
			        _indentLvl--;

	        	}
	        	
	        } else {
	        	
	        	System.err.println(getIndent() + "Could not statically deduce any methods on "
	        		+ (scopeImplsAwareType != null ? scopeImplsAwareType.getType() : "the local class")
	        		+ " with matching method signature");
	        }
        }
    }

	private SymbolTable<MethodDeclaration> buildMethodDeclarationSymbolTable(
			MethodCallExpr node,  // The call expression (required to resolve type arguments for parameterized methods)
			ResolvableType scope,  // Might be a FieldEntry, a local VariableEntry etc. with type argument that need to be taken into account
			MethodDeclaration method) {
		
		return SymbolTable.getSymbolTableForMethod(
						method, // The impl method
						SimpleResolvableType.getResolvableTypeList(node.getTypeArgs(), _currentSymbolTable),  // _currentSymbolTable refers to the calling expression's scope
						SymbolTable.getSymbolTableForType(
		        				(ClassOrInterfaceDeclaration)method.getParentNode(),  // The scope impl class
		        				scope.getTypeArgs())); // Type arguments from when the scope impl class instance was declared			        		
	}

	private String getNoKnownImplTypesMsg(MethodCallExpr node,
			ImplsAwareType scopeImplsAwareType, MethodDeclaration method) {
		
		StringBuffer sb = new StringBuffer();
		sb.append("No known impl(s) for scope type ");
		sb.append(scopeImplsAwareType.getType().toString());
		sb.append(", so cannot analyse the method \"");
		sb.append(method.getName());
		sb.append("\"");
		Expression scopeExpr;
		if ((scopeExpr = node.getScope()) != null) {
			sb.append(". Scope type was derived from the following expression at position "); 
			sb.append(node.getScope().getBeginLine());
			sb.append(":");
			sb.append(node.getScope().getBeginColumn());
			sb.append(" in "); 
			sb.append(StaticAnalysisUtils.getClassDeclaration(node).getName());
			sb.append(": ");
			sb.append(scopeExpr.toString());
		}
		return sb.toString();
	}
    
    
    private ImplsAwareType _currentMethodImplsAwareReturnType;
    
    /*
     * Consider using the Object parameter to inject a callback object.
     * The callback object should receive all potentially interesting events 
     * and this method could provide an inline wrapper for it to be notified
     * of every return statement and the actual object type being returned.
     * This can be added to a ImplsAwareType object local to this method and subsequently pushed
     */
	@Override
	public void visit(MethodDeclaration node, LiferayCodeAnalytics arg) {
		
		logGeneric(node);
		ensureReadyToAnalyse(node);
		
		_log.info(getIndent() + "Method signature: " + JavaLangUtils.getMethodSignatureString(node));
				
		// Inject implementation object types into method parameters, if any have been provided by visit(MethodCallExpr...)
		if (_currentInvocationArgsList != null) {
			Iterator<ImplsAwareType> a = _currentInvocationArgsList.iterator();	
			for (Parameter param : node.getParameters()) {
				SymbolTable<?>.ParameterEntry paramEntry = _currentSymbolTable.getParameterEntry(param.getId().getName());
				
				ImplsAwareType argType = a.next();
				if (!argType.isPrimitiveType()) {
					paramEntry.addPossibleImplTypes(argType.getPossibleImplTypes());
					_log.debug(getIndent() + "ParameterEntry " + paramEntry.getName() + " updated with impls resulting in: " + paramEntry.serialize());
				}
			}
		}
				
		ImplsAwareType implsAwareType;
		
		// Need to resolve the method return type in case it is derived from a generic type argument
		if (node.getType() instanceof PrimitiveType) {
			implsAwareType = new InlineImplsAwareType(node.getType(), _currentSymbolTable.getTypeDeclarationSymbolTable());	
		} else {
			implsAwareType = new InlineImplsAwareType(
					ASTHelper.createReferenceType(_currentSymbolTable.resolveType(node.getType().toString()), 0),
					_currentSymbolTable);
		}				
		
		// Continue analysing this method unless it's in a Java core class
		if (isMethodInteresting(node)) {
			
			_currentMethodImplsAwareReturnType = implsAwareType;
			_indentLvl++;
			super.visit(node, arg);
			_indentLvl--;
			_currentMethodImplsAwareReturnType = implsAwareType;
			
		}
		
		_log.info(getIndent() + "About to push ImplsAwareType return type: " + implsAwareType.serialize());
		pushType(implsAwareType);
		
	}
	
	@Override
	public void visit(ReturnStmt n, LiferayCodeAnalytics arg) {
		
		ensureReadyToAnalyse(n);
		
		super.visit(n, arg);
		
		_log.info(getIndent() + "## Return statement");
		
		// TODO Do I need to weed out duplicated?
		_currentMethodImplsAwareReturnType.addPossibleImplTypes(popType().getPossibleImplTypes());
	}
	
	@Override
	public void visit(BlockStmt node, LiferayCodeAnalytics arg) {
		
		ensureReadyToAnalyse(node);
		
		SymbolTable<?> resumeSymbolTable = _currentSymbolTable;
		_currentSymbolTable = SymbolTable.getSymbolTable(node, (List<ResolvableType>)null, _currentSymbolTable.getTypeDeclarationSymbolTable());
		super.visit(node, arg);
		_currentSymbolTable = resumeSymbolTable;
	}
	
	@Override
	public void visit(CatchClause n, LiferayCodeAnalytics arg) {

		ensureReadyToAnalyse(n);
		
		_log.info(getIndent() + "## CatchClause statement");
		
		MultiTypeParameter except = n.getExcept();
		SymbolTable.getSymbolTable(n).putParameter(except);
		
		// TODO: Consider if the catch block should be analysed
	}
    		
	@Override
	public void visit(ExpressionStmt n, LiferayCodeAnalytics arg) {
		ensureReadyToAnalyse(n);
		super.visit(n, arg);
	}
	
	@Override
	public void visit(ArrayAccessExpr n, LiferayCodeAnalytics arg) {
		logGeneric(n);
		ensureReadyToAnalyse(n);
		_indentLvl++;
		super.visit(n, arg);
		_indentLvl--;
		
		// TODO: Review if ArrayAccessExpr handling is correct
		Entry arrayEntry = _currentSymbolTable.getNamedEntry(n.getName().toString());
		
		ImplsAwareType implsAwareType = new InlineImplsAwareType(ASTHelper.createReferenceType(arrayEntry.getQualifiedType(), ((ReferenceType)arrayEntry.getType()).getArrayCount() - 1), _currentSymbolTable.getTypeDeclarationSymbolTable());
		pushType(implsAwareType);
	}

	@Override
	public void visit(ArrayCreationExpr n, LiferayCodeAnalytics arg) {
		
		logGeneric(n);
		ensureReadyToAnalyse(n);
		_indentLvl++;
		super.visit(n, arg);
		_indentLvl--;
		
		ImplsAwareType implsAwareType = new InlineImplsAwareType(ASTHelper.createReferenceType(_currentSymbolTable.resolveType(n.getType().toString()), n.getArrayCount()), _currentSymbolTable.getTypeDeclarationSymbolTable());
		pushType(implsAwareType);
	}

	@Override
	public void visit(ArrayInitializerExpr n, LiferayCodeAnalytics arg) {
		logGeneric(n);
		ensureReadyToAnalyse(n);
		_indentLvl++;
		super.visit(n, arg);
		_indentLvl--;
	}

	@Override
	public void visit(AssignExpr n, LiferayCodeAnalytics arg) {
		logGeneric(n);
		ensureReadyToAnalyse(n);
		_indentLvl++;
		super.visit(n, arg);
		_indentLvl--;

		ImplsAwareType valueExpr = popType();
		_log.debug("valueExpr class is " + valueExpr.getClass().getName());

		ImplsAwareType variableEntry = popType();
		_log.debug("variableEntry class is " + variableEntry.getClass().getName());
				
		variableEntry.addPossibleImplTypes(valueExpr.getPossibleImplTypes());
		
		pushType(variableEntry);
	}

	@Override
	public void visit(BinaryExpr n, LiferayCodeAnalytics arg) {
		logGeneric(n);
		ensureReadyToAnalyse(n);
		_indentLvl++;
		super.visit(n, arg);
		_indentLvl--;
		
		ImplsAwareType rightExprType = popType();
		ImplsAwareType leftExprType = popType();		

		Type derefLeftType, derefRightType;
		if (leftExprType.getType() instanceof ReferenceType)
			derefLeftType = ((ReferenceType)leftExprType.getType()).getType();
		else
			derefLeftType = leftExprType.getType();
		
		if (rightExprType.getType() instanceof ReferenceType)
			derefRightType = ((ReferenceType)rightExprType.getType()).getType();
		else
			derefRightType = rightExprType.getType();
		
		switch (n.getOperator()) {

			case plus:
				
				// If either argument is an object, then Java will call toString() on it and consider the other argument a String too 
				if (derefLeftType instanceof ClassOrInterfaceType 
						|| derefLeftType instanceof UnknownType
						|| derefRightType instanceof ClassOrInterfaceType
						|| derefRightType instanceof UnknownType) {
					
					pushType(new InlineImplsAwareType(ASTHelper.createReferenceType("java.lang.String", 0), _currentSymbolTable.getTypeDeclarationSymbolTable()));
					break;
				}
				
			case minus:
			case times:
			case divide:
				
				if (derefLeftType instanceof PrimitiveType && derefRightType instanceof PrimitiveType) {
					
					PrimitiveType leftPrimType = (PrimitiveType)derefLeftType;
					PrimitiveType rightPrimType = (PrimitiveType)derefRightType;
					
					if (leftPrimType.getType().equals(rightPrimType.getType())) {
						pushType(new InlineImplsAwareType(leftPrimType, _currentSymbolTable.getTypeDeclarationSymbolTable()));
						
					} else if (JavaLangUtils.canPromoteNumericType(leftPrimType.getType(), rightPrimType.getType())) {
						pushType(new InlineImplsAwareType(rightPrimType, _currentSymbolTable.getTypeDeclarationSymbolTable()));

					} else {
						
						pushType(new InlineImplsAwareType(leftPrimType, _currentSymbolTable.getTypeDeclarationSymbolTable()));
					}
					
				} else {
					throw new AnalyserRuntimeException(new Exception("Analyser doesn't support BinaryExpr comparing Expressions of different primitive types. "
							+"Left expression = { " + n.getLeft().toString() + " } = " + derefLeftType.getClass().getName() + " "
							+ ", Right expression = { " + n.getRight() + " } = "+ derefRightType.getClass().getName()));
				}
				
				break;
				
			case and:
			case or:
			case equals:
			case notEquals:
			case less:
			case lessEquals:
			case greater:
			case greaterEquals:
				
				pushType(new InlineImplsAwareType(new PrimitiveType(Primitive.Boolean), _currentSymbolTable.getTypeDeclarationSymbolTable()));
				break;
	
			case binAnd:
			case binOr:
			case lShift:
			case rSignedShift:
			case rUnsignedShift:
			case remainder:
			case xor:
		
				throw new AnalyserRuntimeException(new Exception("Analyser doesn't support BinaryExpr with operand: " + n.getOperator().toString()));
		}
	}

	@Override
	public void visit(BooleanLiteralExpr n, LiferayCodeAnalytics arg) {
		logGeneric(n);
		ensureReadyToAnalyse(n);
		_indentLvl++;
		super.visit(n, arg);
		_indentLvl--;
		pushType(new InlineImplsAwareType(new PrimitiveType(Primitive.Boolean), _currentSymbolTable.getTypeDeclarationSymbolTable()));
	}

	@Override
	public void visit(CastExpr n, LiferayCodeAnalytics arg) {
		logGeneric(n);
		ensureReadyToAnalyse(n);
		_indentLvl++;
		super.visit(n, arg);
		_indentLvl--;
		
		ImplsAwareType type = popType();

		InlineImplsAwareType castedType = new InlineImplsAwareType(n.getType(), _currentSymbolTable.getTypeDeclarationSymbolTable());
		castedType.addPossibleImplTypes(type.getPossibleImplTypes());
		
		pushType(castedType);
	}

	@Override
	public void visit(CharLiteralExpr n, LiferayCodeAnalytics arg) {
		logGeneric(n);
		ensureReadyToAnalyse(n);
		_indentLvl++;
		super.visit(n, arg);
		_indentLvl--;
		pushType(new InlineImplsAwareType(new PrimitiveType(Primitive.Char), _currentSymbolTable.getTypeDeclarationSymbolTable()));		
	}

	@Override
	public void visit(ClassExpr n, LiferayCodeAnalytics arg) {
		logGeneric(n);
		ensureReadyToAnalyse(n);
		_indentLvl++;
		super.visit(n, arg);
		_indentLvl--;
		
		_log.debug("visit(ClassExpr) about to push InlineImplsAwareType"); 
		pushType(new InlineImplsAwareType(
				ASTHelper.createReferenceType("java.lang.Class", 0), 
				_currentSymbolTable.getTypeDeclarationSymbolTable(), 
				SymbolTable.getSymbolTableForType(ClassLoader.getRequiredDefinition("java.lang.Class"))));
	}

	@Override
	public void visit(ConditionalExpr n, LiferayCodeAnalytics arg) {
		logGeneric(n);
		ensureReadyToAnalyse(n);
		_indentLvl++;
		super.visit(n, arg);
		_indentLvl--;
	}

	@Override
	public void visit(DoubleLiteralExpr n, LiferayCodeAnalytics arg) {
		logGeneric(n);
		ensureReadyToAnalyse(n);
		_indentLvl++;
		super.visit(n, arg);
		_indentLvl--;
	}

	@Override
	public void visit(EnclosedExpr n, LiferayCodeAnalytics arg) {
		logGeneric(n);
		ensureReadyToAnalyse(n);
		_indentLvl++;
		super.visit(n, arg);
		_indentLvl--;
	}

	public void visit(AnnotationMemberDeclaration n, LiferayCodeAnalytics arg) {
		logGeneric(n);
		ensureReadyToAnalyse(n);
		_indentLvl++;
		super.visit(n, arg);
		_indentLvl--;
	}
	
	@Override
	public void visit(FieldAccessExpr n, LiferayCodeAnalytics arg) {
		
		logGeneric(n);
		ensureReadyToAnalyse(n);
		
		// JavaParser sometimes considers fully qualified type notation as field access
		TypeDeclaration def = ClassLoader.getDefinition(n.getScope().toString() + "." + n.getField());
		if (def != null) {
			
			pushType(new InlineImplsAwareType(ASTHelper.createReferenceType(n.getScope().toString() + "." + n.getField(), 0), _currentSymbolTable.getTypeDeclarationSymbolTable(), SymbolTable.getSymbolTableForType(def)));
			return;
		}
		
		n.getScope().accept(this, arg);
		ImplsAwareType resolvableScopeType = popType(); // This might be an Entry class that knows about generic type arguments in its reference type declaration
		
		_log.debug(getIndent() + "Field access scope type is " + resolvableScopeType.getClass().getName() + ": " + resolvableScopeType.serialize());
		
		if (resolvableScopeType.getArrayCount() > 0) {
			_log.debug("Field access scope type is an array");
			if (n.getField().equals("length")) {
				
				pushType(new InlineImplsAwareType(new PrimitiveType(Primitive.Int), _currentSymbolTable.getTypeDeclarationSymbolTable()));
				return;
				
			} else {
				throw new AnalyserRuntimeException(new Exception("Unsupported array field: " + n.getField()));
			}
		}
		
		String resolvedType = resolvableScopeType.getQualifiedType();
		
		SymbolTable<?> resumeSymbolTable = _currentSymbolTable;
		
		if (resolvableScopeType instanceof Entry) {
			_currentSymbolTable = ((Entry)resolvableScopeType).getSymbolTable();
			
		} else {
			_currentSymbolTable =
					SymbolTable.getSymbolTableForType(ClassLoader.getRequiredDefinition(resolvedType));
		}
		
		
		if (_currentSymbolTable.getNode() instanceof ClassOrInterfaceDeclaration) {
		
			SymbolTable<?>.FieldEntry fieldEntry = _currentSymbolTable.getFieldEntry(n.getField());
				
			if (!fieldEntry.isInitialised()) {
			
				FieldDeclaration fieldDeclaration = fieldEntry.getFieldDeclaration();
				
				for (AnnotationExpr annotation : fieldDeclaration.getAnnotations()) {
					if (!annotation.getName().equals("BeanReference")) continue;
					
					_log.debug("AnnotationExpr class is " + annotation.getClass().getName());
				}
				
				
				for (VariableDeclarator varDeclarator : fieldDeclaration.getVariables()) {
					
					if (varDeclarator.getId().equals(fieldEntry.getName()) || varDeclarator.getInit() == null) continue;
					
					_log.debug("Initialising field: " + fieldEntry.getName());
					varDeclarator.getInit().accept(this, arg);
					fieldEntry.addPossibleImplTypes(popType().getPossibleImplTypes());
					
					fieldEntry.setInitialised(true);
					break;
				}
			}
		
			pushType(fieldEntry);
		
		} else if (_currentSymbolTable.getNode() instanceof EnumDeclaration) {
			
			pushType(new InlineImplsAwareType(ASTHelper.createReferenceType(resolvedType, 0), _currentSymbolTable.getTypeDeclarationSymbolTable()));
			
		} else {
			
			throw new AnalyserRuntimeException(new Exception("Unsupported field access scope type: " + _currentSymbolTable.getNode().getClass().getName()));
		}
		
		_currentSymbolTable = resumeSymbolTable;
	}

	@Override
	public void visit(InstanceOfExpr n, LiferayCodeAnalytics arg) {
		logGeneric(n);
		ensureReadyToAnalyse(n);
		_indentLvl++;
		super.visit(n, arg);
		_indentLvl--;
		pushType(new InlineImplsAwareType(new PrimitiveType(Primitive.Boolean), _currentSymbolTable.getTypeDeclarationSymbolTable()));
	}

	@Override
	public void visit(IntegerLiteralExpr n, LiferayCodeAnalytics arg) {
		logGeneric(n);
		ensureReadyToAnalyse(n);
		_indentLvl++;
		super.visit(n, arg);
		_indentLvl--;
		pushType(new InlineImplsAwareType(new PrimitiveType(Primitive.Int), _currentSymbolTable.getTypeDeclarationSymbolTable()));
	}

	@Override
	public void visit(IntegerLiteralMinValueExpr n, LiferayCodeAnalytics arg) {
		logGeneric(n);
		ensureReadyToAnalyse(n);
		_indentLvl++;
		super.visit(n, arg);
		_indentLvl--;
		pushType(new InlineImplsAwareType(new PrimitiveType(Primitive.Int), _currentSymbolTable.getTypeDeclarationSymbolTable()));
	}

	@Override
	public void visit(LongLiteralExpr n, LiferayCodeAnalytics arg) {
		logGeneric(n);
		ensureReadyToAnalyse(n);
		_indentLvl++;
		super.visit(n, arg);
		_indentLvl--;
		pushType(new InlineImplsAwareType(new PrimitiveType(Primitive.Long), _currentSymbolTable.getTypeDeclarationSymbolTable()));
	}

	@Override
	public void visit(LongLiteralMinValueExpr n, LiferayCodeAnalytics arg) {
		logGeneric(n);
		ensureReadyToAnalyse(n);
		_indentLvl++;
		super.visit(n, arg);
		_indentLvl--;
		pushType(new InlineImplsAwareType(new PrimitiveType(Primitive.Long), _currentSymbolTable.getTypeDeclarationSymbolTable()));
	}

	@Override
	public void visit(MarkerAnnotationExpr n, LiferayCodeAnalytics arg) {
		logGeneric(n);
		ensureReadyToAnalyse(n);
		_indentLvl++;
		super.visit(n, arg);
		_indentLvl--;
	}

	@Override
	public void visit(NameExpr n, LiferayCodeAnalytics arg) {
		logGeneric(n);
		ensureReadyToAnalyse(n);
		_indentLvl++;
		super.visit(n, arg);
		_indentLvl--;
		
		ImplsAwareType entry = _currentSymbolTable.getNamedEntry(n.getName());
		
		if (entry == null) {
			String type = _currentSymbolTable.resolveType(n.getName());
			if (type != null) entry = new InlineImplsAwareType(ASTHelper.createReferenceType(_currentSymbolTable.resolveType(type), 0), _currentSymbolTable.getTypeDeclarationSymbolTable(), SymbolTable.getSymbolTableForType(ClassLoader.getRequiredDefinition(type)));
		}
		
		pushType(entry);
	}

	@Override
	public void visit(NormalAnnotationExpr n, LiferayCodeAnalytics arg) {
		logGeneric(n);
		ensureReadyToAnalyse(n);
		_indentLvl++;
		super.visit(n, arg);
		_indentLvl--;
	}

	@Override
	public void visit(NullLiteralExpr n, LiferayCodeAnalytics arg) {
		logGeneric(n);
		ensureReadyToAnalyse(n);
		_indentLvl++;
		super.visit(n, arg);
		_indentLvl--;
		
		pushType(new InlineImplsAwareType(new UnknownType(), _currentSymbolTable.getTypeDeclarationSymbolTable()));
	}

	@Override
	public void visit(ObjectCreationExpr n, LiferayCodeAnalytics arg) {
		logGeneric(n);
		ensureReadyToAnalyse(n);
		_indentLvl++;
		
		if (n.getScope() != null) {
			n.getScope().accept(this, arg);
		}
		if (n.getTypeArgs() != null) {
			for (final Type t : n.getTypeArgs()) {
				t.accept(this, arg);
			}
		}
		n.getType().accept(this, arg);
		if (n.getArgs() != null) {
			for (final Expression e : n.getArgs()) {
				e.accept(this, arg);
			}
		}
		
		// TODO: Implement support for anonymous inner classes
		
		_indentLvl--;
		
		// TODO: Need to handle this in a similar fashion to MethodCallExpr
		
		// For the moment, consider constructors uninteresting and just pop X number of times from the Stack
		// where X is equal to the number of arguments passed to the constructor
		if (n.getArgs() != null) {
			for (Expression expr : n.getArgs()) {
				popType();
			}
		}
		ReferenceType type = new ReferenceType(n.getType(), 0);
		
		List<ResolvableType> typeArgs;
		if (n.getType().getTypeArgs() != null && n.getType().getTypeArgs().size() > 0) {
			typeArgs = new LinkedList<ResolvableType>();
			for (Type typeArg : n.getType().getTypeArgs()) {
				typeArgs.add(new SimpleResolvableType(typeArg, _currentSymbolTable.getTypeDeclarationSymbolTable()));
			}
		} else {
			typeArgs = null;
		}
		
		pushType(
				new InlineImplsAwareType(
						type, 
						_currentSymbolTable.getTypeDeclarationSymbolTable(),
						SymbolTable.getSymbolTableForType(
								(ClassOrInterfaceDeclaration)ClassLoader.getDefinition(_currentSymbolTable.resolveType(type.toString())),
								typeArgs)
		));
	}

	@Override
	public void visit(QualifiedNameExpr n, LiferayCodeAnalytics arg) {

		logGeneric(n);
		ensureReadyToAnalyse(n);
		
		pushType(new InlineImplsAwareType(ASTHelper.createReferenceType(n.toString(), 0), _currentSymbolTable.getTypeDeclarationSymbolTable(), SymbolTable.getSymbolTableForType(ClassLoader.getRequiredDefinition(n.toString()))));
	}

	@Override
	public void visit(SingleMemberAnnotationExpr n, LiferayCodeAnalytics arg) {
		logGeneric(n);
		ensureReadyToAnalyse(n);
		_indentLvl++;
		super.visit(n, arg);
		_indentLvl--;
	}

	@Override
	public void visit(StringLiteralExpr n, LiferayCodeAnalytics arg) {
		logGeneric(n);
		ensureReadyToAnalyse(n);
		_indentLvl++;
		super.visit(n, arg);
		_indentLvl--;		
		
		pushType(new InlineImplsAwareType(ASTHelper.createReferenceType("java.lang.String", 0), _currentSymbolTable.getTypeDeclarationSymbolTable()));		
	}
	
	@Override
	public void visit(SuperExpr n, LiferayCodeAnalytics arg) {
		logGeneric(n);
		ensureReadyToAnalyse(n);
		_indentLvl++;
		super.visit(n, arg);
		
		ClassOrInterfaceType superClassType = StaticAnalysisUtils.getSuperClassType(StaticAnalysisUtils.getClassDeclaration(n));
		
		if (superClassType != null) {
			pushType(new InlineImplsAwareType(superClassType, _currentSymbolTable.getTypeDeclarationSymbolTable()));
		} else {
			// All classes have java.lang.Object as a superclass even if it is not declared
			pushType(new InlineImplsAwareType(ASTHelper.createReferenceType("java.lang.Object", 0), _currentSymbolTable.getTypeDeclarationSymbolTable()));
		}
		
		_indentLvl--;
	}

	@Override
	public void visit(ThisExpr n, LiferayCodeAnalytics arg) {
		logGeneric(n);
		ensureReadyToAnalyse(n);
		_indentLvl++;
		super.visit(n, arg);
		_indentLvl--;
		
		ClassOrInterfaceDeclaration classDef = StaticAnalysisUtils.getClassDeclaration(n);
		InlineImplsAwareType thisType = new InlineImplsAwareType(ASTHelper.createReferenceType(_currentSymbolTable.resolveType(classDef.getName()), 0), _currentSymbolTable.getTypeDeclarationSymbolTable());
		thisType.addPossibleImpl(classDef);
		
		pushType(new InlineImplsAwareType(ASTHelper.createReferenceType(_currentSymbolTable.resolveType(classDef.getName()), 0), _currentSymbolTable.getTypeDeclarationSymbolTable()));
	}

	@Override
	public void visit(UnaryExpr n, LiferayCodeAnalytics arg) {
		logGeneric(n);
		ensureReadyToAnalyse(n);
		_indentLvl++;
		super.visit(n, arg);
		_indentLvl--;
		
		// Don't put anything on the Stack because the type result of a UnaryExpr will be the same as the Expression operand		
	}

	@Override
	public void visit(VariableDeclarationExpr n, LiferayCodeAnalytics arg) {
		logGeneric(n);
		ensureReadyToAnalyse(n);
		_indentLvl++;
		super.visit(n, arg);
		_indentLvl--;
				
		_currentSymbolTable.putVariableDeclaration(n);
		
		for (VariableDeclarator var : n.getVars()) {
			
			if (var.getInit() != null) {
			
				ImplsAwareType assignment = popType();
				
				if (assignment.getPossibleImplTypes() != null) {
					_log.debug(getIndent() + "Adding " + assignment.getPossibleImplTypes().size() + " implementation type(s) for variable \"" + var.getId().getName() + "\"");
					_currentSymbolTable.getVariableEntry(var.getId().getName()).addPossibleImplTypes(assignment.getPossibleImplTypes());
				} else {
					_log.warn("Adding 0 implementation type(s) for variable \"" + var.getId().getName() + "\"");
				}
			}
		}
		
		// The type result of an assignment will be the same as the variable being declared. for example in expressions like: "while ((int i = is.read()) != -1)"  
		//pushType(new InlineImplsAwareType(n.getType()));	
	}

	@Override
	public void visit(LambdaExpr n, LiferayCodeAnalytics arg) {
		logGeneric(n);
		ensureReadyToAnalyse(n);
		_indentLvl++;
		super.visit(n, arg);
		_indentLvl--;
		
		// TODO: This is a Java 8 Lambda function, implement before Liferay runs on Java 8.
	}

	@Override
	public void visit(MethodReferenceExpr n, LiferayCodeAnalytics arg) {
		logGeneric(n);
		ensureReadyToAnalyse(n);
		_indentLvl++;
		super.visit(n, arg);
		_indentLvl--;
		
		// TODO: This is a Java 8 expression, implement before Liferay runs on Java 8.
	}

	@Override
	public void visit(TypeExpr n, LiferayCodeAnalytics arg) {
		logGeneric(n);
		ensureReadyToAnalyse(n);
		_indentLvl++;
		super.visit(n, arg);
		_indentLvl--;
		
		// TypeExpr is just instantiated as scopes for MethodReferenceExpr nodes to encapsulate Types.
		// TODO: This is a Java 8 expression, implement before Liferay runs on Java 8.
	}
	
    private boolean isMethodInteresting(MethodDeclaration node) {
        
		String packageName = ClassLoader.getCompilationUnit(node).getPackage().getName().toString();
		return !packageName.startsWith("java.") 
				&& !packageName.startsWith("javax.") 
				&& !packageName.startsWith("com.liferay.portal.kernel");
    }
    
    private final static org.slf4j.Logger _log = LoggerFactory.getLogger(ExpressionVisitor.class);
}
