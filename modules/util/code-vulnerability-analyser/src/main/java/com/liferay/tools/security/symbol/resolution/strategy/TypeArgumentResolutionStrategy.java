package com.liferay.tools.security.symbol.resolution.strategy;

import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.slf4j.LoggerFactory;

import com.github.javaparser.ast.NamedNode;
import com.github.javaparser.ast.Node;
import com.github.javaparser.ast.TypeParameter;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.type.ClassOrInterfaceType;
import com.github.javaparser.ast.type.UnknownType;
import com.liferay.tools.security.AnalyserRuntimeException;
import com.liferay.tools.security.symbol.SymbolTable;
import com.liferay.tools.security.symbol.UnresolvableSymbolException;
import com.liferay.tools.security.symbol.SymbolTable.ResolutionStrategyOrchestrator;
import com.liferay.tools.security.symbol.resolution.ResolvableType;
import com.liferay.tools.security.symbol.resolution.SimpleResolvableType;

public class TypeArgumentResolutionStrategy implements ResolutionStrategy {

	private Map<String, ResolvableType> _typeArgs;
		
	/**
	 * Merge TypeParameters with TypeArguments to create a Map<String,ResolvableType>
	 * 
	 * @param typeParams
	 * @param typeArgs
	 * @param parameterisedNode
	 * @return
	 */
	public <N extends Node & NamedNode> TypeArgumentResolutionStrategy(
			List<TypeParameter> typeParams,
			List<ResolvableType> typeArgs,
			SymbolTable<N> parameterisedNode) throws InstantiationException {
			
		if (typeParams == null) throw new InstantiationException("No type parameters to map");
		
		Map<String, ResolvableType> mappedTypeArgs = new HashMap<String, ResolvableType>();
		
		if (typeArgs != null && typeArgs.size() == typeArgs.size()) {
			
			_log.trace("Mapping type parameters for \"" + parameterisedNode.getNode().getName() + "\": " + typeArgs.toString());
			
			Iterator<ResolvableType> i = typeArgs.iterator();
			for (TypeParameter param : typeParams) {
				mappedTypeArgs.put(param.getName(), i.next());
			}
			
		} else if (typeArgs == null) {
			
			_log.trace("Mapping type parameters for \"" + parameterisedNode.getNode().getName() + "\": RAW type");
			
			// Raw type, so use type parameter bounds

			for (TypeParameter param : typeParams) {
				
				List<ClassOrInterfaceType> typeBounds = param.getTypeBound();
				if (typeBounds != null && typeBounds.size() > 0) {
					mappedTypeArgs.put(param.getName(), 
							new SimpleResolvableType(new ClassOrInterfaceType(typeBounds.get(0).getName()), parameterisedNode));
				} else {
					mappedTypeArgs.put(param.getName(),
							new SimpleResolvableType(new UnknownType(), parameterisedNode));
							//new SimpleResolvableType(ASTHelper.createReferenceType("java.lang.Object", 0), classDef));
				}
			}
			
		} else {
			
			// An attempt was made to pass an incorrect number of arguments
			throw new AnalyserRuntimeException(new UnresolvableSymbolException(
					"Incorrect number of type arguments provided to " + parameterisedNode.getNode().getName() 
					+ ". Received " + typeArgs.size() + ", expected " + typeParams.size()));
		}
		
		_typeArgs = mappedTypeArgs;
	}

	public String resolveType(String typeReference) throws UnresolvableSymbolException {
		return getResolvableType(typeReference).getQualifiedType();
	}

	public ResolvableType getResolvableType(String typeReference) throws UnresolvableSymbolException {
		
		if (_typeArgs != null && _typeArgs.containsKey(typeReference)) {
			return _typeArgs.get(typeReference);
		}
		
		throw new UnresolvableSymbolException(typeReference);
	}

	private final static org.slf4j.Logger _log = LoggerFactory.getLogger(TypeArgumentResolutionStrategy.class);
}
