package com.liferay.tools.security.symbol.resolution;

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.List;

import com.github.javaparser.ast.Node;
import com.github.javaparser.ast.body.TypeDeclaration;
import com.github.javaparser.ast.expr.Expression;
import com.github.javaparser.ast.type.ReferenceType;
import com.github.javaparser.ast.type.Type;
import com.github.javaparser.ast.visitor.GenericVisitor;
import com.github.javaparser.ast.visitor.VoidVisitor;
import com.liferay.tools.security.symbol.SymbolTable;
import com.liferay.tools.security.symbol.SymbolTable.Entry;
import com.liferay.tools.security.symbol.resolution.strategy.ResolutionStrategy;

public class InlineImplsAwareType extends SimpleResolvableType implements ImplsAwareType { //extends Type {

	// The actual object types that may be referred
	List<SymbolTable<? extends TypeDeclaration>> _impls = new LinkedList<SymbolTable<? extends TypeDeclaration>>();
	
	public InlineImplsAwareType(Type type, ResolutionStrategy rs) {
		super(type, rs);
		_impls = null;
	}
	
	public InlineImplsAwareType(ReferenceType referenceType, SymbolTable node) {
		this(referenceType, node, (List<SymbolTable<? extends TypeDeclaration>>)null);
	}

	@SuppressWarnings("unchecked")
	public InlineImplsAwareType(ReferenceType referenceType, SymbolTable node, SymbolTable<? extends TypeDeclaration> implType) {
		this(referenceType, node, (implType != null ? Arrays.<SymbolTable<? extends TypeDeclaration>>asList(implType) : null));
	}
	
	public InlineImplsAwareType(ReferenceType referenceType, SymbolTable node, List<SymbolTable<? extends TypeDeclaration>> possibleImplTypes) {
		super(referenceType, node);
		if (possibleImplTypes != null) {
			for (SymbolTable<? extends TypeDeclaration> implType : possibleImplTypes) {
				addPossibleImpl(implType);
			}
		}
	}
			
	public void addPossibleImpl(TypeDeclaration implType) {
		if (implType != null)
			getPossibleImplTypes(true).add(SymbolTable.getSymbolTableForType(implType));
	}
	
	public void addPossibleImplTypes(List<SymbolTable<? extends TypeDeclaration>> possibleImplTypes) {		
		if (possibleImplTypes != null)
			getPossibleImplTypes(true).addAll(possibleImplTypes);
	}

	public void addPossibleImpl(SymbolTable<? extends TypeDeclaration> implSymbolTable) {
		if (implSymbolTable != null)
			getPossibleImplTypes(true).add(implSymbolTable);
	}
	
	/**
	 * Returns a List<TypeDeclaration> if the type has been initialised, otherwise null
	 */
	public List<SymbolTable<? extends TypeDeclaration>> getPossibleImplTypes() {
		return getPossibleImplTypes(false);
	}

	private List<SymbolTable<? extends TypeDeclaration>> getPossibleImplTypes(boolean initialiseIfNull) {
		
		if (initialiseIfNull && _impls == null)
			_impls = new LinkedList<SymbolTable<? extends TypeDeclaration>>();
		
		return _impls;
	}

	/**
	 * Returns a String describing the declared type as well as the possible implementation types
	 * @param symbolTable - if not null, will be used to resolve types into fully qualified notation
	 */
	public String serialize() {
		
		StringBuffer sb = new StringBuffer();
		
		if (isUnknownType()) {
			
			sb.append("(unknown type)");
			
		} else {
		
			sb.append(getQualifiedType());
			
			if (getPossibleImplTypes() != null) {
				
				sb.append(':');
			
				// TODO: Consider moving this sorting to the methods that add new members to the List
				Collections.sort(getPossibleImplTypes(), new Comparator<SymbolTable<? extends TypeDeclaration>>() {
					public int compare(SymbolTable<? extends TypeDeclaration> o1, SymbolTable<? extends TypeDeclaration> o2) {				
						return o1.getNode().getName().compareTo(o2.getNode().getName());
					}		
				});
				
				for (SymbolTable<? extends TypeDeclaration> impl : getPossibleImplTypes()) {					
					sb.append(impl.getNode().getName());
					sb.append(',');
				}
				
				sb.deleteCharAt(sb.length() - 1);
			
			} else {
				
				sb.append(" (not initialised)");
			}
		}
		
		return sb.toString();
	}
	
	public boolean encompasses(ImplsAwareType implsAwareType) {
		
		if (implsAwareType == null) return false;
		if (isUnknownType()) {
			
			if (implsAwareType.isUnknownType())
				return true;
			else 
				return false;
			
		} else { 
			
			// Declared type must match exactly
			if (!this.getQualifiedType().equals(implsAwareType.getQualifiedType())) return false;
			
			if (this.getPossibleImplTypes() == null && implsAwareType.getPossibleImplTypes() == null) return true;
			
			if (implsAwareType.getPossibleImplTypes() == null) return true;
			if (this.getPossibleImplTypes() == null) return false;
			
			return this.getPossibleImplTypes().containsAll(implsAwareType.getPossibleImplTypes());
		}
	}
}
