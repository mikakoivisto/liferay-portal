package com.liferay.tools.security.symbol.resolution;

import java.util.LinkedList;
import java.util.List;

import org.slf4j.LoggerFactory;

import com.github.javaparser.ast.body.Parameter;
import com.github.javaparser.ast.type.ClassOrInterfaceType;
import com.github.javaparser.ast.type.PrimitiveType;
import com.github.javaparser.ast.type.ReferenceType;
import com.github.javaparser.ast.type.Type;
import com.github.javaparser.ast.type.UnknownType;
import com.github.javaparser.ast.type.VoidType;
import com.github.javaparser.ast.type.WildcardType;
import com.liferay.tools.security.AnalyserRuntimeException;
import com.liferay.tools.security.symbol.UnresolvableSymbolException;
import com.liferay.tools.security.symbol.resolution.strategy.ResolutionStrategy;

public class SimpleResolvableType implements ResolvableType {

	private Type _type; 
	private ResolutionStrategy _rs;
	
	private List<ResolvableType> _typeArgs;
	
	private int _arrayCount;
	
	public SimpleResolvableType(Type declarationType, ResolutionStrategy rs) {
		
		if (rs == null) throw new AnalyserRuntimeException(new UnresolvableSymbolException("Cannot construct ResolvableType without a valid Node for type resolution"));
		
		_type = declarationType;
		_rs = rs;
		
		List<Type> typeArgs = extractTypeArgs(declarationType);
		
		if (typeArgs != null) {
			_typeArgs = getResolvableTypeList(typeArgs, rs);
		} else
			_typeArgs = null;
		
		if (_type instanceof ReferenceType)
			_arrayCount = ((ReferenceType)_type).getArrayCount();
		else
			_arrayCount = 0;
		
	}
	
	public static List<ResolvableType> getResolvableTypeList(List<Type> types, ResolutionStrategy resolutionTable) {

		if (types != null) {
			
			List<ResolvableType> typeArgs = new LinkedList<ResolvableType>();
			for (Type resolvableType : types) {
				typeArgs.add(new SimpleResolvableType(resolvableType, resolutionTable));
			}
			return typeArgs;
			
		} else {
			return null;
		}
	}
	
	public static List<ResolvableType> getResolvableTypeListFromParameters(List<Parameter> params, ResolutionStrategy resolutionTable) {

		if (params != null) {
			
			List<ResolvableType> typeArgs = new LinkedList<ResolvableType>();
			for (Parameter resolvableParam : params) {
				typeArgs.add(new SimpleResolvableType(resolvableParam.getType(), resolutionTable));
			}
			return typeArgs;
			
		} else {
			return null;
		}
	}

	private static List<Type> extractTypeArgs(Type type) {
		
		if (type instanceof ReferenceType) {
			Type referenceType = ((ReferenceType)type).getType();
			if (referenceType instanceof ClassOrInterfaceType) {
				ClassOrInterfaceType classType = (ClassOrInterfaceType)referenceType;
				return classType.getTypeArgs();
			}
		}
		return null;
	}

	public void setType(Type declarationType) {
		_type = declarationType;
	}

	public Type getType() {
		return _type;
	}

	public String getQualifiedType() {	
		
		_log.trace("getQualifiedType() called for Type: " + _type.toString());
		
		try {
			
			if (isUnknownType()) {
				return "java.lang.Object";
			
			} else if (isWildcardType()) {
				return "?";
				
			} else if (isPrimitiveType()) {
				return getResolutionStrategy().resolveType(_type.toString());
				
			} else {
				
				StringBuffer ret = new StringBuffer();

				ClassOrInterfaceType classType;
				int arrayCount;
				if (_type instanceof ReferenceType) {
					classType = (ClassOrInterfaceType)((ReferenceType)_type).getType();
					arrayCount = ((ReferenceType)_type).getArrayCount();
				} else {
					classType = (ClassOrInterfaceType)_type;
					arrayCount = 0;
				}
				
				String symbol = classType.getName();
				if (classType.getScope() != null) {
					symbol = classType.getScope().toString() + "." + symbol;
				}
				
				String thisType = getResolutionStrategy().resolveType(symbol);
				ret.append(thisType);
				
				if (_typeArgs != null && _typeArgs.size() > 0) {
					ret.append('<');
					for (ResolvableType resolvableType : _typeArgs) {
						
						resolvableType.getQualifiedType();
						ret.append(',');
					}
					ret.deleteCharAt(ret.length() - 1);
					ret.append('>');
				}
				
				for (int i = 0; i < arrayCount; i++)
					ret.append("[]");

				return ret.toString();
			}
			
		} catch (UnresolvableSymbolException e) {
			throw new AnalyserRuntimeException(e);
		}
	}
	
	public void setResolutionStrategy(ResolutionStrategy rs) {
		_rs = rs;
	}
	
	public ResolutionStrategy getResolutionStrategy() {
		return _rs;
	}
	
	public boolean isPrimitiveType() {
		return _type instanceof PrimitiveType || _type instanceof VoidType;
	}
	
	public boolean isUnknownType() {
		return _type instanceof UnknownType;
	}

	public boolean isWildcardType() {
		return _type instanceof WildcardType;
	}
	
	public int getArrayCount() {
		return _arrayCount;
	}

	public List<ResolvableType> getTypeArgs() {
		return _typeArgs;
	}
		
	@Override
	public String toString() {
		return _type.toString();
	}
	
	private final static org.slf4j.Logger _log = LoggerFactory.getLogger(SimpleResolvableType.class);
}
