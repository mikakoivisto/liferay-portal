package com.liferay.tools.security;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FilenameFilter;
import java.io.IOException;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.slf4j.LoggerFactory;

import com.github.javaparser.JavaParser;
import com.github.javaparser.ParseException;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.Node;
import com.github.javaparser.ast.body.AnnotationDeclaration;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.EnumDeclaration;
import com.github.javaparser.ast.body.TypeDeclaration;
import com.github.javaparser.ast.type.ClassOrInterfaceType;
import com.liferay.tools.security.symbol.SymbolTable;
import com.liferay.tools.security.symbol.resolution.ResolvableType;

public class ClassLoader {

	//private static Map<String, CompilationUnit> _loadedCUs = new HashMap<String, CompilationUnit>();
	//private static List<File> _classpathDirs = 
	//		new LinkedList<File>();
	
	private static List<File> _classpathRoots =
			new LinkedList<File>();
	
	private static Set<File> _loadedFiles =
			new HashSet<File>();
	
	private static Map<String, TypeDeclaration> _loadedDefs = 
			new HashMap<String, TypeDeclaration>();

	public static void addClasspathDirectory(File baseDir) throws IOException {
		
		if (!baseDir.isDirectory()) throw new FileNotFoundException("Not a directory: " + baseDir);
		
		//_log.info("Retrieving directories in scope of scan within " + baseDir.getAbsolutePath() + " ...");
		
		//List<File> dirs = FileUtils.getSubdirs(baseDir);
		//dirs.add(baseDir);
		
		//_classpathDirs.addAll(dirs);
		
		_classpathRoots.add(baseDir);

	}
	
	public static void loadFile(File file) throws IOException, ParseException {
		
		CompilationUnit cu;
        
        // creates an input stream for the file to be parsed
        FileInputStream in = new FileInputStream(file);
        
        try {
            // parse the file
            cu = JavaParser.parse(in);

            loadCompilationUnit(cu);
            
        } finally {
            in.close();
		}
	}
	
	public static void loadClassDefinition(String className) throws IOException, ParseException {
		
		final String[] packageStructure = className.split("\\.");
		
		for (File baseDir : _classpathRoots) {
			
			File dir = baseDir, cuFile = null;
			
			_log.trace("Search classpath entry: " + baseDir.getAbsolutePath());
			
			for (int i = 0; i < packageStructure.length && dir != null; i++) {
				
				final String packagePart = packageStructure[i];
				_log.trace("Searching directory " + dir.getName() + " for subdirectories or files named: " + packagePart);
				
				File[] matchedFiles = dir.listFiles(new FilenameFilter() {
					public boolean accept(File dir, String name) {
						_log.trace("Considering subdirectory/file with name: " + name);
						return name.equals(packagePart) || name.equals(packagePart + ".java");
					}
				});
				
				if (matchedFiles == null || matchedFiles.length == 0) {
					_log.trace("Found 0 matches");
					break;
				}
				
				dir = null;
				
				for (File matchedFile : matchedFiles) {
					
					if (matchedFile.isDirectory()) {
						_log.trace("Found relevant sub directory: " + matchedFile.getName());
						dir = matchedFile;
					} else {
						_log.trace("Found relevant file: " + matchedFile.getName());
						cuFile = matchedFile;
					}
				}
				
				// If there is a file matching the package part name and it hasn't already been loaded
				if (cuFile != null && !_loadedFiles.contains(cuFile)) {
					
					_log.debug("Loading definitons from file: " + cuFile.getAbsolutePath());
					
					loadFile(cuFile);
					
					// After loading it, check if it caused the definition of the inner file to be loaded as well
					if (isDefinitionLoaded(className)) {
						return;
					} // Else continue searching with a matching subdirectory if it exists
					
				} else if (_loadedFiles.contains(cuFile)) {
					
					_log.debug("Definitions already loaded from file: " + cuFile.getName());
				}
			}
		}
	}
	
	public static void loadCompilationUnit(final CompilationUnit cu) {
		
		//_log.info("Loading CU in package: " + cu.getPackage().getName().toString());
		
		LiferayCodeVisitor classDeclarationVisitor = new LiferayCodeVisitor() {
			
			@Override
			public void visit(AnnotationDeclaration n, LiferayCodeAnalytics arg) {
				
				String qualifiedClassName = cu.getPackage().getName().toString() + "." + n.getName();
				
				_log.debug("Found annotation: " + qualifiedClassName);
				
				if (!isDefinitionLoaded(qualifiedClassName)) {
				
					//_log.info("Loading class " + qualifiedClassName);
					_loadedDefs.put(qualifiedClassName, n);
					//_loadedCUs.put(node.getName(), cu);
					
					super.visit(n, arg);
				}
			}
			
			@Override
			public void visit(ClassOrInterfaceDeclaration node, LiferayCodeAnalytics arg) {

				StringBuffer outerScopeStr = new StringBuffer();
								
				// Handle inner classes. Ensure they are loaded as {PackageName}.{OuterClass}.{InnerClassName}
				Node outerScope = node;
				while ((outerScope = outerScope.getParentNode()) instanceof ClassOrInterfaceDeclaration) {
					outerScopeStr.insert(0, ((ClassOrInterfaceDeclaration)outerScope).getName());
					outerScopeStr.insert(0, '.');
				}
				
				String qualifiedClassName = cu.getPackage().getName().toString() + outerScopeStr.toString() + "." + node.getName();
				
				_log.debug("Found class or interface: " + qualifiedClassName);
				
				if (!isDefinitionLoaded(qualifiedClassName)) {
				
					//_log.info("Loading class " + qualifiedClassName);
					_loadedDefs.put(qualifiedClassName, node);
					//_loadedCUs.put(node.getName(), cu);
					
					super.visit(node, arg);
				}
			}
			
			@Override
			public void visit(EnumDeclaration n, LiferayCodeAnalytics arg) {

				String qualifiedEnumName = cu.getPackage().getName().toString() + "." + n.getName();
				
				_log.debug("Found enum: " + qualifiedEnumName);

				if (!isDefinitionLoaded(qualifiedEnumName)) {
					_loadedDefs.put(qualifiedEnumName, n);
					super.visit(n, arg);
				}
			}
		};
				
		classDeclarationVisitor.visit(cu, null);
		
		//_log.info("Completed loading of CU in package: " + cu.getPackage().getName().toString());
	}
	
	public static boolean isDefinitionLoaded(String className) {
		
		_log.trace("isDefinitionLoaded(\"" + className + "\")");
		return _loadedDefs.containsKey(className);
	}
	
	/**
	 * Same as getDefinition(), but throws AnalyserRuntimeException(ClasspathException) if the class cannot be found
	 * 
	 * @param className
	 * @return
	 */
	public static TypeDeclaration getRequiredDefinition(String className) {
		TypeDeclaration def = getDefinition(className);
		if (def == null) throw new AnalyserRuntimeException(new ClasspathException(className));
		return def;
	}
	
	public static TypeDeclaration getDefinition(String className) {
		
		int index;
		if ((index = className.indexOf('<')) != -1) {
			className = className.substring(0, index);
		} else if ((index = className.indexOf('[')) != -1) {
			className = className.substring(0, index);
		}
		
		TypeDeclaration def = _loadedDefs.get(className);
		
		if (def == null) {
			
			_log.info("Getting ClassOrInterfaceDeclaration for class: " + className);
			
			// Either the compilation unit hasn't been visited yet,
			// or the corresponding .java file isn't on the provided classpath
			try {
				
				loadClassDefinition(className);
				
			} catch (IOException e) {
				throw new AnalyserRuntimeException(e);
			} catch (ParseException e) {
				throw new AnalyserRuntimeException(e);
			}
			
			def = _loadedDefs.get(className);
		}
		
		return def;
	}
	
	public static Collection<TypeDeclaration> getLoadedDefs() {
		
		List<TypeDeclaration> ret = new LinkedList<TypeDeclaration>();
		ret.addAll(_loadedDefs.values());
		
		Collections.sort(ret, new Comparator<TypeDeclaration>() {
			public int compare(TypeDeclaration o1, TypeDeclaration o2) {
				String def1QualifiedName = SymbolTable.getSymbolTableForType(o1).resolveType(o1.getName());
				String def2QualifiedName =SymbolTable.getSymbolTableForType(o2).resolveType(o2.getName());
				return def1QualifiedName.compareTo(def2QualifiedName);
			}
		});
		
		return ret;
	}
	
	/**
	 * Check if subType is a subclass (or implementation) of superType
	 * 
	 * @param subType
	 * @param superType
	 * @return
	 */
	public static boolean checkSubclassInference(ClassOrInterfaceDeclaration subType, ClassOrInterfaceDeclaration superType) {
		
		_log.debug("Checking if " + subType.getName() + " is a subtype of " + superType.getName());
				
		String superTypeFullyQualifiedName = SymbolTable.getSymbolTableForType(superType).resolveType(superType.getName());
		if (superTypeFullyQualifiedName.equals("java.lang.Object")) return true;
		
		//_log.trace("Checking if the " + (subType.isInterface() ? "interface " : "class ") + subType.getName() + " is a subtype of the " + (superType.isInterface() ? "interface " : "class ") + superType.getName());
		
		if (subType.equals(superType)) {
			
			return true;
						
		} else if (subType.isInterface()) {
			
			_log.debug("Subtype is an interface");
			
			List<ClassOrInterfaceType> subTypeSuperType = subType.getExtends();
			
			if (subTypeSuperType != null) {
				
				_log.debug("Subtype implements: " + subTypeSuperType.toString());
				
				for (ClassOrInterfaceType checkSubTypeSuperType : subTypeSuperType) {
					
					ClassOrInterfaceDeclaration checkSubTypeSuperTypeDef = 
							(ClassOrInterfaceDeclaration)getRequiredDefinition(SymbolTable.getSymbolTableForType(subType).resolveType(checkSubTypeSuperType.toString()));
					
					if (checkSubclassInference(checkSubTypeSuperTypeDef, superType)) return true;
				}
			}
			
			return false;

		} else {
			
			SymbolTable<?> subTypeSymbolTable = SymbolTable.getSymbolTableForType(subType);
			
			do {
								
				if (subTypeSymbolTable.getNode() instanceof ClassOrInterfaceDeclaration) {
					
					subType = (ClassOrInterfaceDeclaration)subTypeSymbolTable.getNode();	
									
					_log.debug("Checking if " + subType.getName() + " is a subtype of " + superType.getName());
					
					if (subType.equals(superType)) {
						
						return true;
						
					} else if (superType.isInterface()) {
						
						List<ClassOrInterfaceType> subTypeSuperType = subType.getImplements();
						
						if (subTypeSuperType != null) {
							
							_log.debug("Subtype implements: " + subTypeSuperType.toString());
							
							for (ClassOrInterfaceType checkSubTypeSuperType : subTypeSuperType) {
								
								ClassOrInterfaceDeclaration checkSubTypeSuperTypeDef = (ClassOrInterfaceDeclaration)getRequiredDefinition(subTypeSymbolTable.resolveType(checkSubTypeSuperType.toString()));
								
								if (checkSubclassInference(checkSubTypeSuperTypeDef, superType)) return true;
							}
						}
					}
				}

			} while ((subTypeSymbolTable = subTypeSymbolTable.getParentScope()) != null);
		}
		
		return false;
	}
	
	public static CompilationUnit getCompilationUnit(String className) {
		Node node = getRequiredDefinition(className);
		return getCompilationUnit(node);
	}

	public static CompilationUnit getCompilationUnit(Node node) {
		
		while (node != null
				&& !((node = node.getParentNode()) instanceof CompilationUnit)) {}
		
		return (CompilationUnit)node;
	}

	public static Collection<TypeDeclaration> getAllLoadedDefinitions() {
		return _loadedDefs.values();
	}
	
	//public static CompilationUnit getCompilationUnit(String className) {
	//	return _loadedCUs.get(className);
	//}

	private final static org.slf4j.Logger _log = LoggerFactory.getLogger(ClassLoader.class);
	
	
	public static class ClasspathException extends Exception {
		
		private static final long serialVersionUID = 1L;

		ClasspathException(String type) {
			super("Could not find " + type + " on the classpath");
		}		
		
		ClasspathException(ResolvableType type) {
			this(type.getQualifiedType());
		}
	}
}
