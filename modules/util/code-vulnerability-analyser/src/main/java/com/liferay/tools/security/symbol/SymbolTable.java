package com.liferay.tools.security.symbol;

import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;

import org.slf4j.LoggerFactory;

import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.NamedNode;
import com.github.javaparser.ast.Node;
import com.github.javaparser.ast.TypeParameter;
import com.github.javaparser.ast.body.AnnotationDeclaration;
import com.github.javaparser.ast.body.AnnotationMemberDeclaration;
import com.github.javaparser.ast.body.BaseParameter;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.EnumDeclaration;
import com.github.javaparser.ast.body.FieldDeclaration;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.body.MultiTypeParameter;
import com.github.javaparser.ast.body.Parameter;
import com.github.javaparser.ast.body.TypeDeclaration;
import com.github.javaparser.ast.body.VariableDeclarator;
import com.github.javaparser.ast.expr.AnnotationExpr;
import com.github.javaparser.ast.expr.MarkerAnnotationExpr;
import com.github.javaparser.ast.expr.NormalAnnotationExpr;
import com.github.javaparser.ast.expr.VariableDeclarationExpr;
import com.github.javaparser.ast.stmt.CatchClause;
import com.github.javaparser.ast.type.ClassOrInterfaceType;
import com.github.javaparser.ast.type.Type;
import com.liferay.tools.security.AnalyserRuntimeException;
import com.liferay.tools.security.ClassLoader;
import com.liferay.tools.security.LiferayCodeVisitor;
import com.liferay.tools.security.LiferayCodeAnalytics;
import com.liferay.tools.security.symbol.resolution.ImplsAwareType;
import com.liferay.tools.security.symbol.resolution.InlineImplsAwareType;
import com.liferay.tools.security.symbol.resolution.ResolvableType;
import com.liferay.tools.security.symbol.resolution.SimpleResolvableType;
import com.liferay.tools.security.symbol.resolution.strategy.CompilationUnitResolutionStrategyImpl;
import com.liferay.tools.security.symbol.resolution.strategy.PrimitiveResolutionStrategyImpl;
import com.liferay.tools.security.symbol.resolution.strategy.ResolutionStrategy;
import com.liferay.tools.security.symbol.resolution.strategy.TypeArgumentResolutionStrategy;
import com.liferay.tools.security.utils.JavaLangUtils;
import com.liferay.tools.security.utils.StaticAnalysisUtils;

/**
 * Represents a SymbolTable containing all named objects in a single "scope". Also holds a reference to the parent scope and outer scope.
 * A "scope" is a Java scope, normally declared using curly braces.
 * Parent scope represents member inheritance. For example all members of a class are inherited by the method scope representing one of its method members.
 * When the current scope is class level, and the class extends another class, the parent scope is the super class.
 * Outer scope is primarily used for type resolution.
 * This SymbolTable or one of its outer scope SymbolTables hold references to ResolutionStrategy, which implements the logic for type reference resolution.
 * In addition, in the case of inner classes, outer scopes also provide access to all members of the outer class from an inner class
 * 
 * @author stiansigvartsen
 */
public class SymbolTable<T extends Node> implements ResolutionStrategy {

	// Static final fields
	
	private static final Set<Class<?>> nodesWithScope = 
			new HashSet<Class<?>>(Arrays.asList(new Class<?>[] {
					CompilationUnit.class, 
					ClassOrInterfaceDeclaration.class, 
					MethodDeclaration.class, 
					//IfStmt.class,
					AnnotationDeclaration.class,
					CatchClause.class,
					EnumDeclaration.class
					}));		
	
	
	// Static tracking fields
	
	private static Map<SymbolTableKey,SymbolTable<ClassOrInterfaceDeclaration>> symbolTablesForClassOrInterface = 
			new HashMap<SymbolTableKey,SymbolTable<ClassOrInterfaceDeclaration>>();
	
	private static Map<Node,SymbolTable<EnumDeclaration>> symbolTablesForEnum =
			new HashMap<Node,SymbolTable<EnumDeclaration>>();

	private static Map<Node,SymbolTable<AnnotationDeclaration>> symbolTablesForAnnotation =
			new HashMap<Node,SymbolTable<AnnotationDeclaration>>();

	private static Map<SymbolTableKey,SymbolTable<MethodDeclaration>> symbolTablesForMethod =
			new HashMap<SymbolTableKey,SymbolTable<MethodDeclaration>>();

	private static Map<Node, SymbolTable<?>> otherSymbolTables = new HashMap<Node, SymbolTable<?>>();
	
	
	// Instance fields
	
	// Parent scope models type inheritance tree
	private SymbolTable<?> _parentScope;
	
	// Outer scopes are used for type resolution. 
	// In addition, Inner classes have an outer scope. They can access all members of the outer class. 
	private SymbolTable<? extends TypeDeclaration> _outerScope; 
	
	// Non-stateful multi-inheritance 
	List<SymbolTable<ClassOrInterfaceDeclaration>> _interfaces;
	
	// The Node that this SymbolTable analyzed
	private T _node;
	
	// For type resolution, responsible to decoding parameterized types and delegating
	// to ResolutonStrategy impls relevant to the particular SymbolTable and its outer scopes
	private ResolutionStrategyOrchestrator _symbolResolver;
	
	private Map<String, VariableEntry> _vars;
	private Map<String, List<MethodDeclaration>> _methods;
	private Map<String, ParameterEntry> _params;
	private Map<String, FieldEntry> _fields;
			
	private SymbolTableKey _key;
	
	private static int tableDepth = 0;

	
	private SymbolTable(T node, SymbolTable<? extends TypeDeclaration> outerScope) {
		_symbolResolver = new ResolutionStrategyOrchestrator();		
		_node = node;
		_outerScope = outerScope;
		_vars = new HashMap<String, VariableEntry>();
		_methods = new HashMap<String, List<MethodDeclaration>>();
		_params = new HashMap<String, ParameterEntry>();
		_fields = new HashMap<String, FieldEntry>();
	}
	
	public static SymbolTable<ClassOrInterfaceDeclaration> getSymbolTableForClassOrInterface(ClassOrInterfaceDeclaration node) {
		return getSymbolTableForClassOrInterface(node, null);
	}

	public static SymbolTable<ClassOrInterfaceDeclaration> getSymbolTableForClassOrInterface(ClassOrInterfaceDeclaration node, List<ResolvableType> typeArgs) {
		return getSymbolTableForClassOrInterface(node, typeArgs, null);
	}
	
	public static SymbolTable<ClassOrInterfaceDeclaration> getSymbolTableForClassOrInterface(ClassOrInterfaceDeclaration node, List<ResolvableType> typeArgs, SymbolTable<? extends TypeDeclaration> outerScope) {
		
		tableDepth++;
		_log.trace(tableDepth + " :: getSymbolTable(node:" + node.getName() + ", typeArgs:" + (typeArgs != null ? typeArgs.toString() : "null") + ", outerScope:" + (outerScope != null) + ")");
		
		SymbolTable<ClassOrInterfaceDeclaration> symbolTable = instantiateAndTrackForClassOrInterfaceDeclaration(node, typeArgs, outerScope);
		
		tableDepth--;
		return symbolTable;
	}
	
	public static SymbolTable<EnumDeclaration> getSymbolTableForEnum(EnumDeclaration node, SymbolTable<? extends TypeDeclaration> outerScope) {
		
		tableDepth++;
		_log.trace(tableDepth + " :: getSymbolTable(node:" + node.getName() + ", outerScope:" + (outerScope != null) + ")");
		
		SymbolTable<EnumDeclaration> symbolTable = instantiateAndTrackForEnumDeclaration(node, outerScope);
		
		tableDepth--;
		return symbolTable;
	}

	public static SymbolTable<AnnotationDeclaration> getSymbolTableForAnnotation(AnnotationDeclaration node) {
		
		tableDepth++;
		_log.trace(tableDepth + " :: getSymbolTable(node:" + node.getName() + ")");
		
		SymbolTable<AnnotationDeclaration> symbolTable = instantiateAndTrackForAnnotationDeclaration(node);

		tableDepth--;
		return symbolTable;
	}

	public static SymbolTable<MethodDeclaration> getSymbolTableForMethod(MethodDeclaration node) {
		return getSymbolTableForMethod(node, null, null);
	}
	
	public static SymbolTable<MethodDeclaration> getSymbolTableForMethod(MethodDeclaration node, List<ResolvableType> typeArgs, SymbolTable<? extends TypeDeclaration> outerScope) {
		
		tableDepth++;
		
		SymbolTable<MethodDeclaration> symbolTable = instantiateAndTrackForMethodDeclaration(node, typeArgs, outerScope);
		
		tableDepth--;
		return symbolTable;
	}

	public static SymbolTable<? extends TypeDeclaration> getSymbolTableForType(TypeDeclaration node) {
		return getSymbolTableForType(node, null);
	}

	public static SymbolTable<? extends TypeDeclaration> getSymbolTableForType(TypeDeclaration node, List<ResolvableType> typeArgs) {
		return getSymbolTableForType(node, typeArgs, null);
	}
	
	public static SymbolTable<? extends TypeDeclaration> getSymbolTableForType(TypeDeclaration node, List<ResolvableType> typeArgs, SymbolTable<? extends TypeDeclaration> outerScope) {
		
		if (node instanceof ClassOrInterfaceDeclaration) {
			return getSymbolTableForClassOrInterface((ClassOrInterfaceDeclaration)node, null, outerScope);
			
		} else if (node instanceof EnumDeclaration) {
			return getSymbolTableForEnum((EnumDeclaration)node, outerScope);
			
		} else if (node instanceof AnnotationDeclaration) { 
			return getSymbolTableForAnnotation((AnnotationDeclaration)node);
		
		} else {
			throw new AnalyserRuntimeException(new Exception("Unsupported TypeDeclaration subtype: " + node.getClass().getName()));
		}
	}
	
	public static SymbolTable<?> getSymbolTable(Node node) {
		return getSymbolTable(node, null, null);
	}

	public static SymbolTable<?> getSymbolTable(Node node, List<ResolvableType> typeArgs) {
		return getSymbolTable(node, typeArgs, null);
	}
	
	public static SymbolTable<?> getSymbolTable(Node node, List<ResolvableType> typeArgs, SymbolTable<? extends TypeDeclaration> outerScope) {
		
		node = getSelfOrParentWithScope(node);
		
		SymbolTable<?> symbolTable;
		
		if (node instanceof TypeDeclaration) {

			return getSymbolTableForType((TypeDeclaration)node, typeArgs, outerScope);
		
		} else if (node instanceof MethodDeclaration) {
			
			return getSymbolTableForMethod((MethodDeclaration)node);
			
		} else {
			
			tableDepth++;
			_log.trace(tableDepth + " :: getSymbolTable(node:" + node.getClass().getName() + ", typeArgs:" + (typeArgs != null ? typeArgs.toString() : "null") + ", outerScope:" + (outerScope != null) + ")");
										
			// block statements, if statements etc.
			symbolTable = instantiateAndTrackForNode(node, typeArgs);
			
			tableDepth--;
			return symbolTable;
		}
	}
	
	private static SymbolTable<MethodDeclaration> instantiateAndTrackForMethodDeclaration(
			Node node, List<ResolvableType> typeArgs,
			SymbolTable<? extends TypeDeclaration> outerScope) {
		
		SymbolTable<MethodDeclaration> symbolTable;
		symbolTable = instantiateForMethodDeclaration((MethodDeclaration)node, typeArgs, outerScope);				
		outerScope = symbolTable.getOuterScope();
		
		SymbolTableKey symbolTableKey = new MethodDeclarationSymbolTableKey(
				(MethodDeclaration)node, 
				symbolTable, 
				(outerScope != null ? (TypeDeclarationSymbolTableKey)outerScope.getKey() : null));
		
		symbolTable.setKey(symbolTableKey);
		
		// method declarations
		SymbolTable<MethodDeclaration> existingSymbolTable = symbolTablesForMethod.get(symbolTableKey);
		
		if (existingSymbolTable != null) {
			tableDepth--;
			return existingSymbolTable;
		}

		_log.trace("Tracking method declaration using key: " + symbolTableKey);
		symbolTablesForMethod.put(symbolTableKey, symbolTable);
		
		symbolTable.processMethodDeclaration((MethodDeclaration)node, symbolTable);
		
		return symbolTable;
	}

	private static SymbolTable<AnnotationDeclaration> instantiateAndTrackForAnnotationDeclaration(AnnotationDeclaration node) {
		
		SymbolTable<AnnotationDeclaration> symbolTable;
		symbolTable = symbolTablesForAnnotation.get(node);
		
		if (symbolTable != null) {
			tableDepth--;
			return symbolTable;
		}
		
		symbolTable = new SymbolTable<AnnotationDeclaration>(node, null);
		
		_log.trace("Tracking TypeDeclaration " + node.getName() + " using itself as key");
		symbolTablesForAnnotation.put(node, symbolTable);
		return symbolTable;
	}

	private static SymbolTable<EnumDeclaration> instantiateAndTrackForEnumDeclaration(
			EnumDeclaration node,
			SymbolTable<? extends TypeDeclaration> outerScope) {
		
		SymbolTable<EnumDeclaration> symbolTable;
		// Enums...
		
		symbolTable = (SymbolTable<EnumDeclaration>)symbolTablesForEnum.get(node);
		
		if (symbolTable != null) {
			tableDepth--;
			return symbolTable;
		}
		
		symbolTable = instantiateForEnumDeclaration(node, outerScope);
		
		_log.trace("Tracking TypeDeclaration " + node.getName() + " using itself as key");
		symbolTablesForEnum.put(node, symbolTable);
		
		symbolTable.processTypeDeclaration(node, symbolTable);
		
		return symbolTable;
	}

	private static SymbolTable<ClassOrInterfaceDeclaration> instantiateAndTrackForClassOrInterfaceDeclaration(
			ClassOrInterfaceDeclaration node, List<ResolvableType> typeArgs,
			SymbolTable<? extends TypeDeclaration> outerScope) {
		
		SymbolTable<ClassOrInterfaceDeclaration> symbolTable;
		SymbolTableKey symbolTableKey = new TypeDeclarationSymbolTableKey(node, typeArgs);
		
		symbolTable = (SymbolTable<ClassOrInterfaceDeclaration>)symbolTablesForClassOrInterface.get(symbolTableKey);
		if (symbolTable != null) {
			tableDepth--;
			return symbolTable;
		}
		
		symbolTable = instantiateForClassOrInterfaceDeclaration(node, typeArgs, outerScope);
		symbolTable.setKey(symbolTableKey);
		
		_log.trace("Tracking ClassOrInterfaceDeclaration using key: " + symbolTableKey);
		symbolTablesForClassOrInterface.put(symbolTableKey, symbolTable);
		
		symbolTable.processTypeDeclaration(node, symbolTable);
		
		return symbolTable;
	}
	
	private static SymbolTable<?> instantiateAndTrackForNode(Node node, List<ResolvableType> typeArgs) {
		
		SymbolTable<?> symbolTable;
		symbolTable = otherSymbolTables.get(node);
		
		if (symbolTable != null) {
			tableDepth--;
			return symbolTable;
		}
		
		_log.trace("Instantiating SymbolTable for non-TypeDeclaration, and linked to its parent SymbolTable...");
		
		symbolTable = new SymbolTable<Node>(node, null);

		if (node.getParentNode() != null) {
			symbolTable._parentScope = getSymbolTable(node.getParentNode(), typeArgs);
		} else {
			symbolTable._parentScope = null;
		}
		
		otherSymbolTables.put(node, symbolTable);
		return symbolTable;
	}

	public SymbolTableKey getKey() {
		return _key;
	}

	private void setKey(SymbolTableKey key) {
		this._key = key;
	}
	
	private static SymbolTable<MethodDeclaration> instantiateForMethodDeclaration(
			MethodDeclaration methodDef, List<ResolvableType> typeArgs, SymbolTable<? extends TypeDeclaration> proposedOuterScope) {
		
		SymbolTable<? extends TypeDeclaration> outerScope = buildOuterScope(methodDef, proposedOuterScope);
		
		SymbolTable<MethodDeclaration> symbolTable = new SymbolTable<MethodDeclaration>(
				methodDef, 
				outerScope);
		
		if (methodDef.getTypeParameters() != null && methodDef.getTypeParameters().size() > 0) {
			try {
				symbolTable.getResolutionStrategyOrchestrator().addResolutionStrategy(new TypeArgumentResolutionStrategy(symbolTable.getNode().getTypeParameters(), typeArgs, symbolTable));
			} catch (InstantiationException e) {
				throw new AnalyserRuntimeException(e);
			}
		}
		
		// For methods, the parent (for member inheritance) and outer (for type resolution) is the same SymbolTable
		symbolTable._parentScope = outerScope;
		
		return symbolTable;
	}
	
	private static SymbolTable<ClassOrInterfaceDeclaration> instantiateForClassOrInterfaceDeclaration(
			ClassOrInterfaceDeclaration classDef, List<ResolvableType> typeArgs, SymbolTable<? extends TypeDeclaration> outerScope) {
				
		_log.trace("instantiateForClassOrInterfaceDeclaration(\"" + classDef.getName() + "\", typeArgs?" + (typeArgs != null) + ", outerScope?" + (outerScope != null) + ")");
		
		// Ensure that the SymbolTable is fully constructed will full type resolution capability by including outerScope 
		SymbolTable<ClassOrInterfaceDeclaration> symbolTable = new SymbolTable<ClassOrInterfaceDeclaration>(
				classDef, 
				// If there is an outer scope as would be the case if node refers to an inner class
				(classDef.getParentNode() instanceof ClassOrInterfaceDeclaration ? buildOuterScope(classDef, outerScope) : null));
		
		if (classDef.getParentNode() instanceof CompilationUnit) {
			symbolTable.getResolutionStrategyOrchestrator().addResolutionStrategy(new PrimitiveResolutionStrategyImpl());
			symbolTable.getResolutionStrategyOrchestrator().addResolutionStrategy(new CompilationUnitResolutionStrategyImpl((CompilationUnit)classDef.getParentNode()));
		}
		
		if (classDef instanceof ClassOrInterfaceDeclaration && classDef.getTypeParameters() != null && classDef.getTypeParameters().size() > 0) {
			try {
				symbolTable.getResolutionStrategyOrchestrator().addResolutionStrategy(new TypeArgumentResolutionStrategy(symbolTable.getNode().getTypeParameters(), typeArgs, symbolTable));
			} catch (InstantiationException e) {
				throw new AnalyserRuntimeException(e);
			}
		}
		
		List<ClassOrInterfaceType> superClass = classDef.getExtends();
		
		if (superClass != null && superClass.size() > 0) {  // Has a super class
			
			ClassOrInterfaceDeclaration superClassDef = (ClassOrInterfaceDeclaration)ClassLoader.getRequiredDefinition(symbolTable.resolveType(superClass.get(0).toString()));
			
			// Pass on references to ResolvableTypes provided as a type argument to the class represented by "node",
			// because then they remain resolvable from the super type.
			// Any super type type arguments that are specified as concrete classes must be represented by new ResolvableTypes 
			
			List<ResolvableType> superTypeArgs = buildTypeArgs(superClass.get(0), symbolTable);
			
			symbolTable._parentScope = getSymbolTableForClassOrInterface(superClassDef, superTypeArgs);
		
		} else if (!classDef.equals(ClassLoader.getRequiredDefinition("java.lang.Object"))) {

			// else the implicit superclass is Object
			symbolTable._parentScope = getSymbolTableForType(ClassLoader.getRequiredDefinition("java.lang.Object"), null);
			
		} else {
			// else node represents java.lang.Object which has no super class
		}
		
		List<ClassOrInterfaceType> superInterfaces;
		
		if (classDef.isInterface()) {			
			superInterfaces = classDef.getExtends();						
		} else {			
			superInterfaces = classDef.getImplements();
		}
		
		if (superInterfaces != null && superInterfaces.size() > 0) {  // Has a super class
			
			symbolTable._interfaces = new LinkedList<SymbolTable<ClassOrInterfaceDeclaration>>();
			
			for (ClassOrInterfaceType interfaceType : superInterfaces) {
				
				ClassOrInterfaceDeclaration superInterfaceDef = (ClassOrInterfaceDeclaration)ClassLoader.getRequiredDefinition(symbolTable.resolveType(interfaceType.toString()));
				List<ResolvableType> superInterfaceArgs = buildTypeArgs(interfaceType, symbolTable);
				
				symbolTable._interfaces.add(getSymbolTableForClassOrInterface(superInterfaceDef, superInterfaceArgs));
			}
		}

		return symbolTable;
	}

	private static SymbolTable<EnumDeclaration> instantiateForEnumDeclaration(
			EnumDeclaration classDef, SymbolTable<? extends TypeDeclaration> outerScope) {
				
		_log.trace("instantiateForEnumDeclaration(\"" + classDef.getName() + "\", outerScope?" + (outerScope != null) + ")");
		
		// Ensure that the SymbolTable is fully constructed will full type resolution capability by including outerScope 
		SymbolTable<EnumDeclaration> symbolTable = new SymbolTable<EnumDeclaration>(
				classDef, 
				// If there is an outer scope as would be the case if node refers to an inner class
				(classDef.getParentNode() instanceof ClassOrInterfaceDeclaration ? buildOuterScope(classDef, outerScope) : null));
		
		if (classDef.getParentNode() instanceof CompilationUnit) {
			symbolTable.getResolutionStrategyOrchestrator().addResolutionStrategy(new PrimitiveResolutionStrategyImpl());
			symbolTable.getResolutionStrategyOrchestrator().addResolutionStrategy(new CompilationUnitResolutionStrategyImpl((CompilationUnit)classDef.getParentNode()));
		}
		
		return symbolTable;
	}

	private static List<ResolvableType> buildTypeArgs(ClassOrInterfaceType def, SymbolTable<ClassOrInterfaceDeclaration> symbolTable) {
		
		List<ResolvableType> superTypeArgs;
		
		if (def.getTypeArgs() != null) {
			
			superTypeArgs = new LinkedList<ResolvableType>();
			
			for (Type superTypeArgType : def.getTypeArgs()) {					
				superTypeArgs.add(new SimpleResolvableType(superTypeArgType, symbolTable));
			}
			
		} else {
			superTypeArgs = null;
		}
		return superTypeArgs;
	}
	
	private static SymbolTable<? extends TypeDeclaration> buildOuterScope(
			TypeDeclaration classDef,
			SymbolTable<? extends TypeDeclaration> proposedOuterScope) {
		
		ClassOrInterfaceDeclaration parentNodeClassDef = (ClassOrInterfaceDeclaration)classDef.getParentNode();
		
		_log.trace("Setting ._outerScope of " + classDef.getName() +  " to " + parentNodeClassDef.getName());
		
		if (proposedOuterScope != null) {

			if (classDef.getParentNode().equals(proposedOuterScope.getNode())) {
				throw new AnalyserRuntimeException(new UnresolvableSymbolException("Provided OUTER_CLASS is type \"" + proposedOuterScope.getNode().getName() 
						+ "\", not expected type " + ((TypeDeclaration)classDef.getParentNode()).getName() + "\""));
			}
			
			return proposedOuterScope;
			
		} else {
			
			return getSymbolTableForType(parentNodeClassDef);
		}
	}

	private static SymbolTable<? extends TypeDeclaration> buildOuterScope(
			MethodDeclaration methodDef,
			SymbolTable<? extends TypeDeclaration> proposedOuterScope) {
		
		ClassOrInterfaceDeclaration parentNodeClassDef = (ClassOrInterfaceDeclaration)methodDef.getParentNode();
		
		_log.trace("Setting ._outerScope of " + methodDef.getName() +  " to " + parentNodeClassDef.getName());
		
		if (proposedOuterScope != null) {
			
			if (!methodDef.getParentNode().equals(proposedOuterScope.getNode())) {
				throw new AnalyserRuntimeException(new UnresolvableSymbolException("Provided OUTER_CLASS is type \"" + proposedOuterScope.getNode().getName() 
						+ "\", not expected type \"" + ((TypeDeclaration)methodDef.getParentNode()).getName() + "\""));
			}
			
			return proposedOuterScope;
			
		} else {
			
			return getSymbolTableForClassOrInterface(parentNodeClassDef);
		}
	}

	private void processTypeDeclaration(TypeDeclaration node, final SymbolTable<?> symbolTable_) {
		
		LiferayCodeVisitor classDeclarationVisitor = new LiferayCodeVisitor() {
			
			FieldDeclaration _currentFieldDeclaration;
			
			@Override
			public void visit(NormalAnnotationExpr n, LiferayCodeAnalytics arg) {
				
				// Only process @BeanReference for the moment
				if (!symbolTable_.resolveType(n.getName().getName()).equals("com.liferay.portal.kernel.bean.BeanReference")) return;
				
				String fieldTypeQualifiedName = symbolTable_.resolveType(_currentFieldDeclaration.getType().toString());
				String implTypeQualifiedName = BeanMapper.getQualifiedImplName(fieldTypeQualifiedName);
									
				for (VariableDeclarator varDeclarator : _currentFieldDeclaration.getVariables()) {
					SymbolTable<?>.FieldEntry fieldEntry = symbolTable_.getFieldEntry(varDeclarator.getId().getName());
					fieldEntry.addPossibleImpl(ClassLoader.getRequiredDefinition(implTypeQualifiedName));
				}	

				super.visit(n, arg);
			}
			
			@Override
			public void visit(AnnotationMemberDeclaration n,
					LiferayCodeAnalytics arg) {

				super.visit(n, arg);
			}
			
			@Override
			public void visit(MarkerAnnotationExpr n,
					LiferayCodeAnalytics arg) {
				
				super.visit(n, arg);
			}
			
			@Override
			public void visit(FieldDeclaration node, LiferayCodeAnalytics arg) {	
				
				// Only add fields from this class, not fields of inner classes
				if (node.getParentNode() != symbolTable_.getNode()) return;
				
				symbolTable_.putFieldDeclaration(node);
				
				_currentFieldDeclaration = node;
				for (AnnotationExpr annotationExpr : node.getAnnotations()) {
					annotationExpr.accept(this, arg);
				}
			}
			
			@Override
			public void visit(MethodDeclaration node, LiferayCodeAnalytics arg) {
				
				// Only add methods from this class, not methods of inner classes
				if (node.getParentNode() != symbolTable_.getNode()) return;
									
				//_log.info("Adding method " + node.getName() + " to SymbolTable for " + ((ClassOrInterfaceDeclaration)symbolTable_.getNode()).getName() + " of type " +  symbolTable_.getNode().getClass().getName());
				symbolTable_.putMethodDeclaration(node);
			}
		};	
		node.accept(classDeclarationVisitor, null);
	}
	
	private void processMethodDeclaration(Node node,
			SymbolTable<?> symbolTable) {
		
		for (Parameter param : ((MethodDeclaration)node).getParameters()) {
			symbolTable.putParameter(param);
		}
	}	
	
	private static Node getSelfOrParentWithScope(Node node) {
		while (node != null && !nodesWithScope.contains(node.getClass())) {
			node = node.getParentNode();
		}
		return node;
	}
	
	/**
	 * Returns the parent SymbolTable or itself which is for a TypeDeclaration. 
	 * @return
	 */
	@SuppressWarnings("unchecked")
	public SymbolTable<? extends TypeDeclaration> getTypeDeclarationSymbolTable() {
		
		if (getNode() instanceof TypeDeclaration) 
			return (SymbolTable<? extends TypeDeclaration>)this;
		else
			return _parentScope.getTypeDeclarationSymbolTable();
	}
	
	public T getNode() {
		return _node;
	}
	
	public Entry getNamedEntry(String id) {
	
		_log.debug("getNamedEntry(\"" + id + "\")");
		
		SymbolTable<?>.ParameterEntry paramEntry = getParameterEntry(id);
		if (paramEntry != null) return paramEntry;
		
		SymbolTable<?>.VariableEntry varEntry = getVariableEntry(id);
		if (varEntry != null) return varEntry;

		SymbolTable<?>.FieldEntry fieldEntry = getFieldEntry(id);
		if (fieldEntry != null) return fieldEntry;

		return null;
	}

	
	public String resolveTypeOfNameExpr(String name) {

		if (name.equals("this")) 
			return resolveType(StaticAnalysisUtils.getClassDeclaration(getNode()).getName());
				
		SymbolTable<?>.ParameterEntry paramEntry = getParameterEntry(name);
		if (paramEntry != null) return resolveType(paramEntry.getType().toString());		
		
		SymbolTable<?>.VariableEntry varEntry = getVariableEntry(name);
		if (varEntry != null) return resolveType(varEntry.getType().toString());

		SymbolTable<?>.FieldEntry fieldEntry = getFieldEntry(name);
		if (fieldEntry != null) return resolveType(fieldEntry.getType().toString());
		
		String resolvedExternalType = resolveType(name);
		if (resolvedExternalType != null) {
			return resolvedExternalType;
		}

		return null;
	}
	
	private String resolveConcreteType(String typeReference) {
		
		ResolutionStrategy resolver = getResolutionStrategyOrchestrator();
		
		try {
			
			return resolver.resolveType(typeReference);
			
		} catch (UnresolvableSymbolException e) {
			throw new AnalyserRuntimeException(e);
		}
	}
	
	public String resolveType(String typeReference) {

		StringBuffer ret = new StringBuffer();
		
		final StringTokenizer st = new StringTokenizer(typeReference, "<>? ,[]", true);
		final Set<String> specialChars = new HashSet<String>(Arrays.asList(new String[] {"<", ">", "?", " ", ",", "[", "]", "super", "extends"}));
		
		String token;
		while (st.hasMoreTokens()) {

			token = st.nextToken();
			
			if (specialChars.contains(token)) {
				ret.append(token);
			} else {				
				ret.append(resolveConcreteType(token));
			}
		}
		
		return ret.toString();
	}
		
	public SymbolTable<?>.VariableEntry getVariableEntry(String variableId) {
		
		VariableEntry varEntry = _vars.get(variableId);
		
		if (varEntry == null && _parentScope != null) {
			return _parentScope.getVariableEntry(variableId);
		} else
			return varEntry;
	}
	
	public void putVariableDeclaration(VariableDeclarationExpr varExpr) {
		
		for (VariableDeclarator var : varExpr.getVars()) {
			_vars.put(var.getId().getName(), new VariableEntry(varExpr, var.getId().getName()));
		}
	}
	
	public SymbolTable<?>.FieldEntry getFieldEntry(String fieldId) {
		
		FieldEntry fieldEntry = _fields.get(fieldId);
		
		if (fieldEntry == null && _parentScope != null) {
			return _parentScope.getFieldEntry(fieldId);
		} else
			return fieldEntry;
	}
	
	public void putFieldDeclaration(FieldDeclaration fieldDeclaration) {
		
		for (VariableDeclarator var : fieldDeclaration.getVariables()) {
			_fields.put(var.getId().getName(), new FieldEntry(fieldDeclaration, var.getId().getName()));
		}		
	}
	
	public List<MethodDeclaration> getMethodDeclaration(String methodName) {
		
		//_log.info("Searching for methods named \"" + methodName + "\" in symbol table for " + _node.getClass().getName());
		
		List<MethodDeclaration> localList = _methods.get(methodName);
		if (localList == null) localList = new LinkedList<MethodDeclaration>();
		
		//_log.info("Found " + localList.size() + " methods");
		
		if (_parentScope != null) {
			
			Set<String> methodSigs = new HashSet<String>();
			for (MethodDeclaration method : localList) {
				methodSigs.add(JavaLangUtils.getMethodSignatureString(method));
			}
			
			List<MethodDeclaration> superMethods = _parentScope.getMethodDeclaration(methodName);
			for (MethodDeclaration superMethod : superMethods) {
				
				// Check if the super method has been overridden
				if (!methodSigs.contains(JavaLangUtils.getMethodSignatureString(superMethod))) {
					// If not then add it to the returned method list
					localList.add(superMethod);
				}
			}
			
			if (_interfaces != null) {
				for (SymbolTable<ClassOrInterfaceDeclaration> superInterface : _interfaces) {
					
					superMethods = superInterface.getMethodDeclaration(methodName);
					for (MethodDeclaration superMethod : superMethods) {
						
						// Check if the super method has been overridden
						if (!methodSigs.contains(JavaLangUtils.getMethodSignatureString(superMethod))) {
							// If not then add it to the returned method list
							localList.add(superMethod);
						}
					}
				}
			}

		}
		
		return localList;
	}
	
	public void putMethodDeclaration(MethodDeclaration method) {
		
		String methodName = method.getName();
		
		List<MethodDeclaration> methodList = _methods.get(methodName);
		if (methodList == null) {
			methodList = new LinkedList<MethodDeclaration>();
			_methods.put(methodName, methodList);
		}
		
		methodList.add(method);
	}
	
	public SymbolTable<?>.ParameterEntry getParameterEntry(String paramId) {
		
		ParameterEntry paramEntry = _params.get(paramId);
		
		if (paramEntry == null && _parentScope != null) {
			return _parentScope.getParameterEntry(paramId);
		} else
			return paramEntry;
	}
	
	public void putParameter(Parameter param) {		
		_params.put(param.getId().getName(), new ParameterEntry(param, param.getId().getName()));
	}	
	
	public void putParameter(MultiTypeParameter param) {		
		_params.put(param.getId().getName(), new ParameterEntry(param, param.getId().getName()));
	}	

	public SymbolTable<?> getParentScope() {
		return _parentScope;
	}
	
	public SymbolTable<? extends TypeDeclaration> getOuterScope() {
		return _outerScope;
	}

	@Override
	public String toString() {
		return serialize(getNode());
	}
	
	@Override
	public boolean equals(Object obj) {
		
		if (!(obj instanceof SymbolTable)) return false;
		
		SymbolTable<?> objST = (SymbolTable<?>)obj;
		if (getKey() == null && objST.getKey() != null) return false;		
		return getKey().equals(objST.getKey());
	}
	
	@Override
	public int hashCode() {
		
		if (getKey() == null) throw new AnalyserRuntimeException(new Exception("hashCode() called on a SymbolTable without a SymbolTableKey"));		
		return getKey().hashCode();
	}
	
	private String serialize(Node fromNode) {
		
		int level = 0;
		SymbolTable<?> st = this;
		
		while (st.getParentScope() != null) {
			level++;
			st = st.getParentScope();
		}
		
		StringBuffer sb = new StringBuffer();

		// If "this" SymbolTable represents the outer scope of the fromNode ...
		if (_outerScope != null && getNode() == fromNode.getParentNode()) {
			// ... then members from "this" outer scope are accessible
			sb.append(_outerScope.serialize(fromNode));
		}

		if (_parentScope != null) {
			sb.append(_parentScope.serialize(fromNode));
		}
		
		indent(sb, level);
		sb.append("{");
		sb.append(_node.getClass().getName());
		
		if (_node instanceof ClassOrInterfaceDeclaration) {
			sb.append(' ');
			sb.append('[');
			sb.append(resolveType(((ClassOrInterfaceDeclaration)_node).getName()));
			
			List<TypeParameter> typeParams = ((ClassOrInterfaceDeclaration)_node).getTypeParameters();
			if (typeParams != null && typeParams.size() > 0) {
				sb.append('<');
				for (TypeParameter typeParam : typeParams) {
					//sb.append(_typeArgs.get(typeParam.getName()).getQualifiedType());
					sb.append(resolveType(typeParam.getName()));
					sb.append(',');
				}
				sb.deleteCharAt(sb.length() - 1);
				sb.append('>');
			}
			
			sb.append(']');
		} else if (_node instanceof MethodDeclaration) {
			sb.append(' ');
			sb.append('[');
			sb.append(((MethodDeclaration)_node).getName());
			sb.append(']');
		}
		
		//sb.append('{');
		sb.append('\n');
		writeSymbols(level, sb);		
		
		return sb.toString();
	}

	private void writeSymbols(int level, StringBuffer sb) {

		for (String fieldName : _fields.keySet()) {

			indent(sb, level + 1);
			
			// A variable declaration
			sb.append(_fields.get(fieldName).serialize()); sb.append(' '); sb.append(fieldName);
			sb.append('\n');
		}
		
		for (String paramName : _params.keySet()) {
			
			indent(sb, level + 1);
			
			// A variable declaration
			sb.append(_params.get(paramName).serialize()); sb.append(' '); sb.append(paramName);
			sb.append('\n');
		}
		
		for (String varName : _vars.keySet()) {

			indent(sb, level + 1);
			
			// A variable declaration
			sb.append(_vars.get(varName).serialize()); sb.append(' '); sb.append(varName);
			sb.append('\n');
		}
		
		for (String methodName : _methods.keySet()) {			
			
			for (MethodDeclaration method : _methods.get(methodName)) {
			
				indent(sb, level + 1);
				
				// A variable declaration
				sb.append(resolveType(method.getType().toString())); sb.append(' '); sb.append(methodName);
				
				sb.append('(');
				
				for (Parameter param : method.getParameters()) {
					sb.append(resolveType(param.getType().toString())); sb.append(','); sb.append(' ');
				}
				
				if (method.getParameters().size() > 0)
					sb.delete(sb.length() -2, sb.length());
				
				sb.append(')');
				sb.append('\n');				
			}
		}
	}
	
	private void indent(StringBuffer sb, int indentation) {
		
		for (int i = 0; i < indentation; i++) {
			sb.append(' ');
		}
	}
	
	private final static org.slf4j.Logger _log = LoggerFactory.getLogger(SymbolTable.class);
	
	
	/**
	 * Inner classes follow that represent members types of a Node represented by "this" SymbolTable
	 */
	
	public interface Entry extends ImplsAwareType {
		public String getName();
		public SymbolTable<?> getSymbolTable();
	}
	
	public class FieldEntry extends InlineImplsAwareType implements Entry {
		
		private String _name;
		private FieldDeclaration _field;
		private boolean _initialised = false;
		
		public FieldEntry(FieldDeclaration field, String name) {
			super(field.getType(), SymbolTable.this);
			_field = field;
			_name = name;
		}
		
		public String getName() {
			return _name;
		}
		
		public FieldDeclaration getFieldDeclaration() {
			return _field;
		}
		
		public boolean isInitialised() {
			return _initialised;
		}
		
		public void setInitialised(boolean initialised) {
			_initialised = initialised;
		}
		
		public SymbolTable<T> getSymbolTable() {
			return SymbolTable.this;
		}
		
		@Override
		public String getQualifiedType() {
			return getSymbolTable().resolveType(getType().toString());
		}
	}
	
	public class VariableEntry extends InlineImplsAwareType implements Entry {
		
		private String _name;
		private VariableDeclarationExpr _var;
		
		public VariableEntry(VariableDeclarationExpr var, String name) {
			super(var.getType(), SymbolTable.this);
			_var = var;
			_name = name;
		}
		
		public String getName() {
			return _name;
		}
		
		public VariableDeclarationExpr getVariableDeclarationExpr() {
			return _var;
		}		
		
		public SymbolTable<T> getSymbolTable() {
			return SymbolTable.this;
		}
		
		@Override
		public String getQualifiedType() {
			return getSymbolTable().resolveType(getType().toString());
		}
	}
	
	public class ParameterEntry extends InlineImplsAwareType implements Entry {
		
		private String _name;
		private BaseParameter _param;
		
		public ParameterEntry(Parameter param, String name) {
			super(param.getType(), SymbolTable.this);
			_param = param;
			_name = name;
		}
		
		public ParameterEntry(MultiTypeParameter param, String name) {
			super(param.getTypes().get(0), SymbolTable.this);
			_param = param;
			_name = name;
		}

		public String getName() {
			return _name;
		}
		
		public BaseParameter getParameter() {
			return _param;
		}	
		
		public SymbolTable<T> getSymbolTable() {
			return SymbolTable.this;
		}
		
		@Override
		public String getQualifiedType() {
			return getSymbolTable().resolveType(getType().toString());
		}
	}
	
	public SymbolTable<?>.ResolutionStrategyOrchestrator getResolutionStrategyOrchestrator() {
		
		if (_symbolResolver == null) {
		
			if (_outerScope != null) {
				return _outerScope.getResolutionStrategyOrchestrator();
			} else if (_parentScope != null) {
				return _parentScope.getResolutionStrategyOrchestrator();
			} else {
				return null;
			}
		} else {
			return _symbolResolver;
		}
	}
	
	public class ResolutionStrategyOrchestrator implements ResolutionStrategy {
		
		private List<ResolutionStrategy> _strategies;
		private Map<String, String> _cache = new HashMap<String, String>();
		
		public ResolutionStrategyOrchestrator() {
			_strategies = new LinkedList<ResolutionStrategy>();
		}
		
		public SymbolTable<T>.ResolutionStrategyOrchestrator addResolutionStrategy(ResolutionStrategy resolutionStrategy) {
			_strategies.add(resolutionStrategy);
			return this;
		}
		
		public List<ResolutionStrategy> getResolutionStrategies() {
			return _strategies;
		}
		
		public String resolveType(String typeReference) throws UnresolvableSymbolException {
			
			_log.trace("resolveType(\"" + typeReference + "\") on SymbolTable of " + (_node instanceof ClassOrInterfaceDeclaration ? ((ClassOrInterfaceDeclaration)_node).getName() : "non-class"));
			
			// Check and return resolved symbol from the _cache
			if (_cache.containsKey(typeReference)) {
				_log.trace("Returning from cache");
				return _cache.get(typeReference);
			}
			
			SymbolTable<?>.ResolutionStrategyOrchestrator resolver = this;
			
			do {
				
				SymbolTable<?> symbolTable = resolver.getSymbolTable();
				
				for (ResolutionStrategy resolutionStrategy : resolver.getResolutionStrategies()) {
					
					_log.trace("SymbolTable for " + ((NamedNode)symbolTable.getNode()).getName() + " trying to resolve \"" + typeReference + "\" using strategy " + resolutionStrategy.getClass().getName());
					
					try {

						String resolvedType = resolutionStrategy.resolveType(typeReference);						

						_log.debug("SymbolTable for " + ((NamedNode)symbolTable.getNode()).getName() + " resolved \"" + typeReference + "\" to \"" + resolvedType + "\" using strategy " + resolutionStrategy.getClass().getName());
						_cache.put(typeReference, resolvedType);
						return resolvedType;

					} catch (UnresolvableSymbolException e) {
						continue;
					}
				}
				
				if (getNode() instanceof NamedNode) {
					_log.trace("SymbolTable for " + ((NamedNode)getNode()).getName() + " failed to resolve \"" + typeReference + "\". Trying outer scope...");
				} else {
					_log.trace("SymbolTable for " + getNode().getClass().getName() + " failed to resolve \"" + typeReference + "\". Trying outer scope...");
				}
				
				if (symbolTable.getOuterScope() != null) {
					resolver = symbolTable.getOuterScope().getResolutionStrategyOrchestrator();
				} else {
					if (!(symbolTable.getNode() instanceof ClassOrInterfaceDeclaration)) {
						resolver = symbolTable.getParentScope().getResolutionStrategyOrchestrator();
					} else {
						resolver = null;
					}
				}
				
			} while (resolver != null);
			
			throw new UnresolvableSymbolException(typeReference);		
		}
		
		public SymbolTable<T> getSymbolTable() {
			return SymbolTable.this;
		}
	}
}