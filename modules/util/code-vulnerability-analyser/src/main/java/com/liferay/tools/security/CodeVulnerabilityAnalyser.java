package com.liferay.tools.security;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.ResourceBundle;

import org.slf4j.LoggerFactory;

import com.github.javaparser.ASTHelper;
import com.github.javaparser.JavaParser;
import com.github.javaparser.ParseException;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.Node;
import com.github.javaparser.ast.body.BodyDeclaration;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.body.ModifierSet;
import com.github.javaparser.ast.body.TypeDeclaration;
import com.github.javaparser.ast.expr.ClassExpr;
import com.github.javaparser.ast.expr.FieldAccessExpr;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.ast.expr.NameExpr;
import com.github.javaparser.ast.stmt.BlockStmt;
import com.github.javaparser.ast.stmt.Statement;
import com.liferay.tools.security.symbol.SymbolTable;
import com.liferay.tools.security.symbol.resolution.ImplsAwareType;
import com.liferay.tools.security.symbol.resolution.InlineImplsAwareType;
import com.liferay.tools.security.utils.JavaLangUtils;
import com.liferay.tools.security.utils.StaticAnalysisUtils;


public class CodeVulnerabilityAnalyser {

	public static void main(String args[]) throws IOException, ParseException {
		
		ResourceBundle rb = getProperties();
		System.out.println(rb.getString("jdkSrc"));
		
		System.out.println(args.length);
		
		if (args != null && args.length != 0 && args.length != 2) {
			System.err.println("Usage: java CodeVulnerabilityAnalyser [{className} {methodName}]");
			System.exit(0);
		}
		
		try {
			
			loadClasspath();
			
		} catch (IOException e) {
			System.err.println("Failed to load classpath: " + e.getMessage());
			System.exit(0);
		}
		
		_log.info("**** CLASS LOADING PHASE COMPLETED SUCCESSFULLY. LOADED " + ClassLoader.getAllLoadedDefinitions().size() + " CLASSES ****");
		
		ClassOrInterfaceDeclaration def;
		String methodName;
		
		if (args.length > 0) {
			def = (ClassOrInterfaceDeclaration)ClassLoader.getRequiredDefinition(args[0]);
		} else {
			def = (ClassOrInterfaceDeclaration)ClassLoader.getRequiredDefinition("com.liferay.bookmarks.service.impl.BookmarksEntryServiceImpl");
		}
		
		if (args.length > 1) {
			methodName = args[1];
		} else {
			methodName = "deleteEntry";
		}

		SymbolTable<ClassOrInterfaceDeclaration> defST = SymbolTable.getSymbolTableForClassOrInterface(def);
		List<MethodDeclaration> entryMethods = defST.getMethodDeclaration(methodName);
		
		if (entryMethods == null || entryMethods.size() == 0) {
			System.err.println("Could not find any methods called " + methodName + "(...) in " + def.getName());
			System.exit(0);
		}
		
		LiferayCodeAnalytics analytics = initialiseAnalytics();
	
	    for (LiferayCodeVisitor visitor : VisitorFactory.getVisitors(def)) {
	    	_log.info("========================================");
	    	_log.info("Analysing code using: " + visitor.getClass().getName());
	    	_log.info("========================================");
	    	visitor.visit(entryMethods.get(0), analytics);
		}
		
		_log.info("All visitors execution complete");
		
		produceReport(analytics);
    }
	
	public static ResourceBundle getProperties() {		
		String userId = System.getProperty("user.name");
		ResourceBundle rb = ResourceBundle.getBundle("analyser-env-" + userId);		
		return rb;
	}
	
	private static String[] coreSourceDirs = new String[] {
		"/portal-impl/src",
		"/portal-service/src",
		"/util-java/src"};

	
	public static void loadClasspath() throws IOException {
		
		ResourceBundle rb = getProperties();
		
		ClassLoader.addClasspathDirectory(new File(rb.getString("jdkSrc")));
		String repoBaseDir = rb.getString("liferayRepoBaseDir");
		
		for (String sourceDir : coreSourceDirs) {
			
			File baseDir = new File(repoBaseDir + sourceDir);
			
			if (!baseDir.exists()) {
				throw new FileNotFoundException("Cannot find directory: " + baseDir.getAbsolutePath());
			}
			
			ClassLoader.addClasspathDirectory(baseDir);
		}
		
		loadModulesIn(repoBaseDir + "/modules/portal");
		loadModulesIn(repoBaseDir + "/modules/apps/*");
	}

	/**
	 * Load classes for modules in specific parent directory.
	 * The wildcard * represents any directory name, so you can provide /modules/apps/* 
	 * which will then load every modules represented in a subdirectories of the directory matched with *
	 * 
	 * @param modulesDir
	 * @throws FileNotFoundException
	 * @throws IOException
	 */
	private static void loadModulesIn(String modulesDir) throws FileNotFoundException, IOException {
		
		int wildcardIndex = modulesDir.indexOf("/*");
		
		if (wildcardIndex != -1) {

			File portalModulesDir = new File(modulesDir.substring(0, wildcardIndex));
			
			for (File moduleDir : portalModulesDir.listFiles()) {
				if (!moduleDir.isDirectory()) continue;
				loadModulesIn(modulesDir.substring(0, wildcardIndex) + "/" + moduleDir.getName() + modulesDir.substring(wildcardIndex + 2, modulesDir.length()));				
			}			
			
		} else {
			
			File portalModulesDir = new File(modulesDir);

			if (!portalModulesDir.exists()) {
				throw new FileNotFoundException("Cannot find directory: " + portalModulesDir.getAbsolutePath());
			}
			
			for (File moduleDir : portalModulesDir.listFiles()) {
				if (!moduleDir.isDirectory()) continue;
				
				File moduleSrcDir = new File(moduleDir, "/src");
				if (moduleSrcDir.isDirectory()) ClassLoader.addClasspathDirectory(moduleSrcDir);
			}
		}
	}
	
	public static LiferayCodeAnalytics initialiseAnalytics() {
		
		LiferayCodeAnalytics analytics = new LiferayCodeAnalytics();
		
		Map<MethodInvocationArgs, ImplsAwareType> mock = new HashMap<MethodInvocationArgs, ImplsAwareType>();
		mock.put(
				new MethodInvocationArgs(), 
				new InlineImplsAwareType(
						ASTHelper.createReferenceType("com.liferay.bookmarks.service.BookmarksEntryLocalService", 0),
						SymbolTable.getSymbolTableForType(ClassLoader.getRequiredDefinition("com.liferay.bookmarks.service.BookmarksEntryLocalService")),
						SymbolTable.getSymbolTableForType(ClassLoader.getRequiredDefinition("com.liferay.bookmarks.service.impl.BookmarksEntryLocalServiceImpl")))
		);
		
		analytics.addMock("com.liferay.bookmarks.service.BookmarksEntryLocalServiceUtil#getService()", mock);
		
		mock = new HashMap<MethodInvocationArgs, ImplsAwareType>();
		mock.put(
				new MethodInvocationArgs(), 
				new InlineImplsAwareType(
						ASTHelper.createReferenceType("com.liferay.bookmarks.service.BookmarksFolderLocalService", 0),
						SymbolTable.getSymbolTableForType(ClassLoader.getRequiredDefinition("com.liferay.bookmarks.service.BookmarksFolderLocalService")),
						SymbolTable.getSymbolTableForType(ClassLoader.getRequiredDefinition("com.liferay.bookmarks.service.impl.BookmarksFolderLocalServiceImpl")))
		);
		
		analytics.addMock("com.liferay.bookmarks.service.BookmarksFolderLocalServiceUtil#getService()", mock);

		return analytics;
	}
	
	private static void produceReport(LiferayCodeAnalytics analytics) {
		
		_log.info("##############################");
		_log.info("Visited the following methods:");
		for (SymbolTable<MethodDeclaration> methodST : analytics.getMethodDeclarations()) {
			_log.info("==========");
			
			_log.info(methodST.getKey().serialize());			

			for (MethodCallExpr methodCallExpr : analytics.getInvocationExprs(methodST)) {
				
				MethodDeclaration invokingMethod = StaticAnalysisUtils.getMethodDeclaration(methodCallExpr);
				
				StringBuffer sb = new StringBuffer();
				sb.append("|_" + StaticAnalysisUtils.getClassDeclaration(methodCallExpr).getName() + " (line " + methodCallExpr.getBeginLine() + ")");
				if (invokingMethod != null) {
					sb.append(" in " + JavaLangUtils.getMethodSignatureString(invokingMethod));
				}
				_log.info(sb.toString());
			}
		}
		_log.info("##############################");
		
		_log.info("Warnings:");
		for (String warning : analytics.getWarnings()) {
			_log.info(warning);
		}
		_log.info("##############################");
	}
	
	private final static org.slf4j.Logger _log = LoggerFactory.getLogger(CodeVulnerabilityAnalyser.class);
}
