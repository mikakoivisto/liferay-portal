package com.liferay.tools.security;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import com.github.javaparser.ast.body.TypeDeclaration;
import com.liferay.tools.security.symbol.SymbolTable;
import com.liferay.tools.security.symbol.resolution.ImplsAwareType;

public class MethodInvocationArgs extends LinkedList<ImplsAwareType> {
	
	private static final long serialVersionUID = 1L;

	public MethodInvocationArgs() {
		super();
	}
	
	public MethodInvocationArgs(List<ImplsAwareType> argTypes) {
		super(argTypes);
	}
			
	/**
	 * Two MethodInvocation objects are only considered equal if all argument implementation types match
	 */
	public boolean equals(Object obj) {
		
		if (!(obj instanceof MethodInvocationArgs)) return false;
		
		MethodInvocationArgs methodInvocation2 = (MethodInvocationArgs)obj;
		
		if (size() != methodInvocation2.size()) return false;
		
		Iterator<ImplsAwareType> i2 = methodInvocation2.iterator();
		for (ImplsAwareType argType : this) {
			
			ImplsAwareType objArgType2 = i2.next();
			
			if (!argType.getQualifiedType().equals(objArgType2.getQualifiedType())) return false;
			
			if (argType.getPossibleImplTypes() != null && objArgType2.getPossibleImplTypes() == null) return false;
			if (argType.getPossibleImplTypes() == null && objArgType2.getPossibleImplTypes() != null) return false;
			
			if (argType.getPossibleImplTypes() != null) {
				Iterator<SymbolTable<? extends TypeDeclaration>> j2 = objArgType2.getPossibleImplTypes().iterator();
				for (SymbolTable<? extends TypeDeclaration> implType : argType.getPossibleImplTypes()) {
					
					SymbolTable<? extends TypeDeclaration> objArgImplType2 = j2.next();
					
					// TODO: Consider if it would be useful to compare impl types using fully qualified names
					if (!implType.getNode().getName().equals(objArgImplType2.getNode().getName())) return false;
				}
			}
		}
		
		return true;
	}
	
	@Override
	public int hashCode() {

		StringBuffer sb = new StringBuffer();
		for (ImplsAwareType argType : this) {
			sb.append(argType.serialize());
			sb.append("|");
		}
		
		return sb.toString().hashCode();
	}
	
	public boolean encompasses(MethodInvocationArgs invocationArgs) {
		Iterator<ImplsAwareType> i = invocationArgs.iterator();
		for (ImplsAwareType thisArg : this) {
			
			// If compared to fewer invocation arguments
			if (!i.hasNext()) return false;
			
			if (!thisArg.encompasses(i.next())) {
				return false;
			}
		}
		return true;
	}
}
